diff --git a/lib/sw_apps/zynqmp_fsbl/data/zynqmp_fsbl.tcl b/lib/sw_apps/zynqmp_fsbl/data/zynqmp_fsbl.tcl
index 6bd68ec5f6..19fb56dd5d 100644
--- a/lib/sw_apps/zynqmp_fsbl/data/zynqmp_fsbl.tcl
+++ b/lib/sw_apps/zynqmp_fsbl/data/zynqmp_fsbl.tcl
@@ -1,18 +1,44 @@
 #/******************************************************************************
-#* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-#* SPDX-License-Identifier: MIT
+#*
+#* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+#*
+#* Permission is hereby granted, free of charge, to any person obtaining a copy
+#* of this software and associated documentation files (the "Software"), to deal
+#* in the Software without restriction, including without limitation the rights
+#* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+#* copies of the Software, and to permit persons to whom the Software is
+#* furnished to do so, subject to the following conditions:
+#*
+#* The above copyright notice and this permission notice shall be included in
+#* all copies or substantial portions of the Software.
+#*
+#* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+#* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+#* THE SOFTWARE.
+#*
+#*
+#*
 #******************************************************************************/
 
-
 proc swapp_get_name {} {
-    return "Zynq MP FSBL";
+    return "Zynq MP FSBL (TE modified)";
 }
 
 proc swapp_get_description {} {
     return "First Stage Bootloader (FSBL) for Zynq Ultrascale+ MPSoC. The FSBL configures the FPGA with HW bit stream (if it exists) \
 	and loads the Operating System (OS) Image or Standalone (SA) Image or 2nd Stage Boot Loader image from the \
 	non-volatile memory (NAND/SD/QSPI) to RAM (DDR) and takes A53/R5 out of reset.  It supports multiple partitions, \
-	and each partition can be a code image or a bit stream.";
+	and each partition can be a code image or a bit stream. \n\n\
+    Modified Files: xfsbl_main.c, xfsbl_hooks.h/.c, xfsbl_board.h/.c(search for 'TE Mod' on source code) \n\
+    Add Files:  te_xfsbl_hooks.h/.c (for hooks and board)\n\
+    General Changes:  Display FSBL Banner and Device Name \n\
+    Add TE_Custom Files:  te_xfsbl_hooks_te0xxxx.h/.c (module specific changes <-> no changes if not included)\n\
+    Template: SDK 2019.2\n\
+  ";
 }
 
 proc swapp_get_supported_processors {} {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/Makefile b/lib/sw_apps/zynqmp_fsbl/src/Makefile
index b619e14956..6f793cb5c3 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/Makefile
+++ b/lib/sw_apps/zynqmp_fsbl/src/Makefile
@@ -1,9 +1,29 @@
 #/******************************************************************************
-#* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-#* SPDX-License-Identifier: MIT
+#*
+#* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+#*
+#* Permission is hereby granted, free of charge, to any person obtaining a copy
+#* of this software and associated documentation files (the "Software"), to deal
+#* in the Software without restriction, including without limitation the rights
+#* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+#* copies of the Software, and to permit persons to whom the Software is
+#* furnished to do so, subject to the following conditions:
+#*
+#* The above copyright notice and this permission notice shall be included in
+#* all copies or substantial portions of the Software.
+#*
+#* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+#* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+#* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+#* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+#* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+#* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+#* THE SOFTWARE.
+#*
+#*
+#*
 #******************************************************************************/
 
-
 PROC ?= a53
 CROSS ?=
 BSP_DIR	:= ../misc/zynqmp_fsbl_bsp
@@ -28,7 +48,7 @@ AS      :=      $(CROSS)armr5-none-eabi-gcc
 LINKER  :=      $(CROSS)armr5-none-eabi-gcc
 DUMP    :=      $(CROSS)armr5-none-eabi-objdump -xSD
 CFLAGS :=  -Wall -O0 -g3 -fmessage-length=0
-ECFLAGS := -g -DARMR5 -Wall -mcpu=cortex-r5 -mfloat-abi=hard -mfpu=vfpv3-d16 -Os -flto -ffat-lto-objects
+ECFLAGS := -g -DARMR5 -Wall -Wextra -mcpu=cortex-r5 -mfloat-abi=hard -mfpu=vfpv3-d16 -Os -flto -ffat-lto-objects
 LSCRIPT := -Tlscript.ld
 EXEC := ron_r5_fsbl.elf
 INCLUDEPATH := -I$(BSP_DIR)/psu_cortexr5_0/include -I. -I../misc/$(BOARD)/$(PROC) -I../misc/$(BOARD)
@@ -70,7 +90,7 @@ CC      :=      $(CROSS)arm-none-eabi-gcc
 AS      :=      $(CROSS)arm-none-eabi-gcc
 LINKER  :=      $(CROSS)arm-none-eabi-gcc
 DUMP    :=      $(CROSS)arm-none-eabi-objdump -xSD
-ECFLAGS :=	-march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16 -DARMA53_$(A53_STATE) -Os -flto -ffat-lto-objects
+ECFLAGS :=  -Wextra -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3-d16 -DARMA53_$(A53_STATE) -Os -flto -ffat-lto-objects
 LSCRIPT :=	-Tlscript.ld
 LDFLAGS :=  -Wl,--start-group,-lxil,-lxilffs,-lxilsecure,-lxilpm,-lgcc,-lc,--end-group -L$(LIBPATH) -L./ -Wl,--build-id=none -march=armv7-a -mfloat-abi=hard -mfpu=vfpv3
 OBJS += $(patsubst %.S, %.o, $(S_SOURCES))
diff --git a/lib/sw_apps/zynqmp_fsbl/src/lscript.ld b/lib/sw_apps/zynqmp_fsbl/src/lscript.ld
index e9650b3cf6..bfa58ada71 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/lscript.ld
+++ b/lib/sw_apps/zynqmp_fsbl/src/lscript.ld
@@ -1,7 +1,27 @@
 /******************************************************************************
 *
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
 /*******************************************************************/
@@ -23,7 +43,7 @@ _UNDEF_STACK_SIZE = DEFINED(_UNDEF_STACK_SIZE) ? _UNDEF_STACK_SIZE : 256;
 
 MEMORY
 {
-   psu_ram_0_S_AXI_BASEADDR : ORIGIN = 0xFFFC0000, LENGTH = 0x00029E00
+   psu_ram_0_S_AXI_BASEADDR : ORIGIN = 0xFFFC0000, LENGTH = 0x00029D00
    psu_ram_1_S_AXI_BASEADDR : ORIGIN = 0xFFFE9E00, LENGTH = 0x00000200
    psu_ram_2_S_AXI_BASEADDR : ORIGIN = 0xFFFF0040, LENGTH = 0x0000FDC0
 }
@@ -50,10 +70,7 @@ SECTIONS
    *(.vfp11_veneer)
    *(.ARM.extab)
    *(.gnu.linkonce.armextab.*)
-} > psu_ram_0_S_AXI_BASEADDR
-
-.note.gnu.build-id : {
-   KEEP (*(.note.gnu.build-id))
+   *(.note.gnu.build-id)
 } > psu_ram_0_S_AXI_BASEADDR
 
 .init : {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/lscript_a53.ld b/lib/sw_apps/zynqmp_fsbl/src/lscript_a53.ld
index 8283d7903c..5d32044fde 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/lscript_a53.ld
+++ b/lib/sw_apps/zynqmp_fsbl/src/lscript_a53.ld
@@ -1,7 +1,27 @@
 /******************************************************************************
 *
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
 /*******************************************************************/
@@ -16,7 +36,7 @@ _HEAP_SIZE = DEFINED(_HEAP_SIZE) ? _HEAP_SIZE : 1024;
 
 MEMORY
 {
-   psu_ocm_ram_0_S_AXI_BASEADDR : ORIGIN = 0xFFFC0000, LENGTH = 0x00029E00
+   psu_ocm_ram_0_S_AXI_BASEADDR : ORIGIN = 0xFFFC0000, LENGTH = 0x00029D00
    psu_ocm_ram_1_S_AXI_BASEADDR : ORIGIN = 0xFFFE9E00, LENGTH = 0x00000200
    psu_ocm_ram_2_S_AXI_BASEADDR : ORIGIN = 0xFFFF0040, LENGTH = 0x0000FDC0
 
@@ -45,10 +65,6 @@ SECTIONS
    *(.gnu.linkonce.armextab.*)
 } > psu_ocm_ram_0_S_AXI_BASEADDR
 
-.note.gnu.build-id : {
-   KEEP (*(.note.gnu.build-id))
-} > psu_ocm_ram_0_S_AXI_BASEADDR
-
 .init (ALIGN(64)): {
    KEEP (*(.init))
 } > psu_ocm_ram_0_S_AXI_BASEADDR
diff --git a/lib/sw_apps/zynqmp_fsbl/src/scatter_r5.scat b/lib/sw_apps/zynqmp_fsbl/src/scatter_r5.scat
deleted file mode 100755
index 9b9fef465d..0000000000
--- a/lib/sw_apps/zynqmp_fsbl/src/scatter_r5.scat
+++ /dev/null
@@ -1,77 +0,0 @@
-#! armclang --target=arm-arm-nonie-eabi -march=armv8-a -E -x c
-
-#define PSU_OCM_0_MEM_START	0xFFFC0000
-#define PSU_OCM_0_MEM_LENGTH	0x39CC0
-
-#define ROM_SECTION_LENGTH	0x00022000
-#define ROM_SECTION_START	PSU_OCM_0_MEM_START
-#define BSS_SECTION_LENGTH	0x00003000
-#define DATA_SECTION_LENGTH	0x00001000
-#define DUP_DATA_SECTION_LENGTH	0x00001000
-#define BSS_SECTION_START_OFFSET	0
-#define DATA_SECTION_START_OFFSET	0
-#define HEAP_SECTION_LENGTH	0x400
-#define HEAP_SECTION_START_OFFSET	0
-#define DUP_DATA_SECTION_START_OFFSET	0
-#define STACK_SECTION_LENGTH	0x2000
-#define STACK_SECTION_START	(ROM_SECTION_START + ROM_SECTION_LENGTH + DATA_SECTION_LENGTH + DUP_DATA_SECTION_LENGTH + BSS_SECTION_LENGTH + HEAP_SECTION_LENGTH + STACK_SECTION_LENGTH)
-#define ATF_BUFFER_LENGTH	0x200
-#define BITSTREAN_BUFFER_LENGTH 0xFDC0
-
-PSU_OCM_0_MEM PSU_OCM_0_MEM_START PSU_OCM_0_MEM_LENGTH
-{
-    ROM_SECTION ROM_SECTION_START ROM_SECTION_LENGTH
-    {
-        asm_vectors.o (vectors, +FIRST)
-        *(+RO)
-    }
-
-
-    DATA_SECTION +DATA_SECTION_START_OFFSET DATA_SECTION_LENGTH
-    {
-        *(+RW)
-    }
-
-    BSS_SECTION +BSS_SECTION_START_OFFSET BSS_SECTION_LENGTH
-    {
-        *(.bss*)
-    }
-
-    ARM_LIB_HEAP +HEAP_SECTION_START_OFFSET EMPTY HEAP_SECTION_LENGTH
-    {
-
-    }
-
-    ARM_LIB_STACK STACK_SECTION_START ALIGN 0x20 EMPTY -STACK_SECTION_LENGTH
-    {
-
-    }
-
-    ARM_IRQ_STACK +0 ALIGN 0x8 EMPTY 0x400
-    {
-
-    }
-    ARM_SV_STACK +0 ALIGN 0x8 EMPTY 0x800
-    {
-
-    }
-    ARM_ABORT_STACK +0 ALIGN 0x8 EMPTY 0x400
-    {
-
-    }
-    ARM_FIQ_STACK +0 ALIGN 0x8 EMPTY 0x400
-    {
-
-    }
-    ARM_UNDEF_STACK +0 ALIGN 0x8 EMPTY 0x400
-    {
-
-    }
-
-    ATF_AND_BITSTREAM_BUFFER_SECTION +BSS_SECTION_START_OFFSET ATF_BUFFER_LENGTH + BITSTREAN_BUFFER_LENGTH
-    {
-        *(.bss.handoff_params)
-        *(.bss.bitstream_buffer)
-    }
-
-}
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_Si5338-Registers.h b/lib/sw_apps/zynqmp_fsbl/src/te_Si5338-Registers.h
new file mode 100644
index 0000000000..ea09b48b3b
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_Si5338-Registers.h
@@ -0,0 +1,440 @@
+//Register map for use with AN428 (JumpStart)
+//http://www.silabs.com/clocks 
+//Copyright 2012 Silicon Laboratories
+//#BEGIN_HEADER
+//Date = Tuesday, January 21, 2020 3:45 PM
+//File version = 3
+//Software Name = ClockBuilder Pro
+//Software version = 2.39.0.0
+//Software date = 12 11, 2019
+//Chip = Si533x
+//Part Number = Si533x
+//#END_HEADER
+//Input Frequency (MHz) = 25.000000000
+//Input Type = CMOS_SSTL_HSTL
+//P1 = 1
+//Input Mux = RefClk
+//FDBK Input Frequency (MHz) = 25.000000000
+//FDBK Input Type = OFF
+//P2 = 1
+//FDBK Mux = NoClk
+//PFD Input Frequency (MHz) = 25.000000000
+//VCO Frequency (GHz) = 2.500000
+//N = 100  (100.0000)
+//Internal feedback enabled
+//Output Clock 0
+// Output Frequency (MHz) = 100.000000000
+// Mux Selection = IDn
+// MultiSynth = 25  (25.0000)
+// R = 1
+//Output Clock 1
+// Output Frequency (MHz) = 125.000000000
+// Mux Selection = IDn
+// MultiSynth = 20  (20.0000)
+// R = 1
+//Output Clock 2
+// Output Frequency (MHz) = 27.000000000
+// Mux Selection = IDn
+// MultiSynth = 92  16/27  (92.5926)
+// R = 1
+//Output Clock 3
+// Output Frequency (MHz) = 100.000000000
+// Mux Selection = IDn
+// MultiSynth = 25  (25.0000)
+// R = 1
+//Driver 0
+// Enabled
+// Powered on
+// Output voltage = 1.80
+// Output type = 1.8V LVDS
+// Output state when disabled = StopLow
+//Driver 1
+// Enabled
+// Powered on
+// Output voltage = 1.80
+// Output type = 1.8V LVDS
+// Output state when disabled = StopLow
+//Driver 2
+// Enabled
+// Powered on
+// Output voltage = 1.80
+// Output type = 1.8V LVDS
+// Output state when disabled = StopLow
+//Driver 3
+// Enabled
+// Powered on
+// Output voltage = 1.80
+// Output type = 1.8V LVDS
+// Output state when disabled = StopLow
+//Clock 0 phase inc/dec step size (ns) = 0.000
+//Clock 1 phase inc/dec step size (ns) = 0.000
+//Clock 2 phase inc/dec step size (ns) = 0.000
+//Clock 3 phase inc/dec step size (ns) = 0.000
+//Phase increment and decrement pin control is off
+//Frequency increment and decrement pin control is off
+//Frequency increment and decrement is disabled
+//Initial phase offset 0 (ns) = 0.000
+//Initial phase offset 1 (ns) = 0.000
+//Initial phase offset 2 (ns) = 0.000
+//Initial phase offset 3 (ns) = 0.000
+//SSC is disabled
+
+#define NUM_REGS_MAX 350
+
+typedef struct Reg_Data{
+   unsigned char Reg_Addr;
+   unsigned char Reg_Val;
+   unsigned char Reg_Mask;
+} Reg_Data;
+
+Reg_Data const code Reg_Store[NUM_REGS_MAX] = {
+{  0,0x00,0x00},
+{  1,0x00,0x00},
+{  2,0x00,0x00},
+{  3,0x00,0x00},
+{  4,0x00,0x00},
+{  5,0x00,0x00},
+{  6,0x08,0x1D},
+{  7,0x00,0x00},
+{  8,0x70,0x00},
+{  9,0x0F,0x00},
+{ 10,0x00,0x00},
+{ 11,0x00,0x00},
+{ 12,0x00,0x00},
+{ 13,0x00,0x00},
+{ 14,0x00,0x00},
+{ 15,0x00,0x00},
+{ 16,0x00,0x00},
+{ 17,0x00,0x00},
+{ 18,0x00,0x00},
+{ 19,0x00,0x00},
+{ 20,0x00,0x00},
+{ 21,0x00,0x00},
+{ 22,0x00,0x00},
+{ 23,0x00,0x00},
+{ 24,0x00,0x00},
+{ 25,0x00,0x00},
+{ 26,0x00,0x00},
+{ 27,0x70,0x80},
+{ 28,0x0B,0xFF},
+{ 29,0x08,0xFF},
+{ 30,0xB0,0xFF},
+{ 31,0xC0,0xFF},
+{ 32,0xC0,0xFF},
+{ 33,0xC0,0xFF},
+{ 34,0xC0,0xFF},
+{ 35,0xAA,0xFF},
+{ 36,0x06,0x1F},
+{ 37,0x06,0x1F},
+{ 38,0x06,0x1F},
+{ 39,0x06,0x1F},
+{ 40,0x84,0xFF},
+{ 41,0x10,0x7F},
+{ 42,0x24,0x3F},
+{ 43,0x00,0x00},
+{ 44,0x00,0x00},
+{ 45,0x00,0xFF},
+{ 46,0x00,0xFF},
+{ 47,0x14,0x3F},
+{ 48,0x3A,0xFF},
+{ 49,0x00,0xFF},
+{ 50,0xC4,0xFF},
+{ 51,0x07,0xFF},
+{ 52,0x10,0xFF},
+{ 53,0x80,0xFF},
+{ 54,0x0A,0xFF},
+{ 55,0x00,0xFF},
+{ 56,0x00,0xFF},
+{ 57,0x00,0xFF},
+{ 58,0x00,0xFF},
+{ 59,0x01,0xFF},
+{ 60,0x00,0xFF},
+{ 61,0x00,0xFF},
+{ 62,0x00,0x3F},
+{ 63,0x10,0xFF},
+{ 64,0x00,0xFF},
+{ 65,0x08,0xFF},
+{ 66,0x00,0xFF},
+{ 67,0x00,0xFF},
+{ 68,0x00,0xFF},
+{ 69,0x00,0xFF},
+{ 70,0x01,0xFF},
+{ 71,0x00,0xFF},
+{ 72,0x00,0xFF},
+{ 73,0x00,0x3F},
+{ 74,0x10,0xFF},
+{ 75,0x4B,0xFF},
+{ 76,0x2C,0xFF},
+{ 77,0x5C,0xFF},
+{ 78,0x00,0xFF},
+{ 79,0x00,0xFF},
+{ 80,0x00,0xFF},
+{ 81,0x1B,0xFF},
+{ 82,0x00,0xFF},
+{ 83,0x00,0xFF},
+{ 84,0x00,0x3F},
+{ 85,0x10,0xFF},
+{ 86,0x80,0xFF},
+{ 87,0x0A,0xFF},
+{ 88,0x00,0xFF},
+{ 89,0x00,0xFF},
+{ 90,0x00,0xFF},
+{ 91,0x00,0xFF},
+{ 92,0x01,0xFF},
+{ 93,0x00,0xFF},
+{ 94,0x00,0xFF},
+{ 95,0x00,0x3F},
+{ 96,0x10,0x00},
+{ 97,0x00,0xFF},
+{ 98,0x30,0xFF},
+{ 99,0x00,0xFF},
+{100,0x00,0xFF},
+{101,0x00,0xFF},
+{102,0x00,0xFF},
+{103,0x01,0xFF},
+{104,0x00,0xFF},
+{105,0x00,0xFF},
+{106,0x80,0xBF},
+{107,0x00,0xFF},
+{108,0x00,0xFF},
+{109,0x00,0xFF},
+{110,0x40,0xFF},
+{111,0x00,0xFF},
+{112,0x00,0xFF},
+{113,0x00,0xFF},
+{114,0x40,0xFF},
+{115,0x00,0xFF},
+{116,0x80,0xFF},
+{117,0x00,0xFF},
+{118,0x40,0xFF},
+{119,0x00,0xFF},
+{120,0x00,0xFF},
+{121,0x00,0xFF},
+{122,0x40,0xFF},
+{123,0x00,0xFF},
+{124,0x00,0xFF},
+{125,0x00,0xFF},
+{126,0x00,0xFF},
+{127,0x00,0xFF},
+{128,0x00,0xFF},
+{129,0x00,0x0F},
+{130,0x00,0x0F},
+{131,0x00,0xFF},
+{132,0x00,0xFF},
+{133,0x00,0xFF},
+{134,0x00,0xFF},
+{135,0x00,0xFF},
+{136,0x00,0xFF},
+{137,0x00,0xFF},
+{138,0x00,0xFF},
+{139,0x00,0xFF},
+{140,0x00,0xFF},
+{141,0x00,0xFF},
+{142,0x00,0xFF},
+{143,0x00,0xFF},
+{144,0x00,0xFF},
+{145,0x00,0x00},
+{146,0xFF,0x00},
+{147,0x00,0x00},
+{148,0x00,0x00},
+{149,0x00,0x00},
+{150,0x00,0x00},
+{151,0x00,0x00},
+{152,0x00,0xFF},
+{153,0x00,0xFF},
+{154,0x00,0xFF},
+{155,0x00,0xFF},
+{156,0x00,0xFF},
+{157,0x00,0xFF},
+{158,0x00,0x0F},
+{159,0x00,0x0F},
+{160,0x00,0xFF},
+{161,0x00,0xFF},
+{162,0x00,0xFF},
+{163,0x00,0xFF},
+{164,0x00,0xFF},
+{165,0x00,0xFF},
+{166,0x00,0xFF},
+{167,0x00,0xFF},
+{168,0x00,0xFF},
+{169,0x00,0xFF},
+{170,0x00,0xFF},
+{171,0x00,0xFF},
+{172,0x00,0xFF},
+{173,0x00,0xFF},
+{174,0x00,0xFF},
+{175,0x00,0xFF},
+{176,0x00,0xFF},
+{177,0x00,0xFF},
+{178,0x00,0xFF},
+{179,0x00,0xFF},
+{180,0x00,0xFF},
+{181,0x00,0x0F},
+{182,0x00,0xFF},
+{183,0x00,0xFF},
+{184,0x00,0xFF},
+{185,0x00,0xFF},
+{186,0x00,0xFF},
+{187,0x00,0xFF},
+{188,0x00,0xFF},
+{189,0x00,0xFF},
+{190,0x00,0xFF},
+{191,0x00,0xFF},
+{192,0x00,0xFF},
+{193,0x00,0xFF},
+{194,0x00,0xFF},
+{195,0x00,0xFF},
+{196,0x00,0xFF},
+{197,0x00,0xFF},
+{198,0x00,0xFF},
+{199,0x00,0xFF},
+{200,0x00,0xFF},
+{201,0x00,0xFF},
+{202,0x00,0xFF},
+{203,0x00,0x0F},
+{204,0x00,0xFF},
+{205,0x00,0xFF},
+{206,0x00,0xFF},
+{207,0x00,0xFF},
+{208,0x00,0xFF},
+{209,0x00,0xFF},
+{210,0x00,0xFF},
+{211,0x00,0xFF},
+{212,0x00,0xFF},
+{213,0x00,0xFF},
+{214,0x00,0xFF},
+{215,0x00,0xFF},
+{216,0x00,0xFF},
+{217,0x00,0xFF},
+{218,0x00,0x00},
+{219,0x00,0x00},
+{220,0x00,0x00},
+{221,0x0D,0x00},
+{222,0x00,0x00},
+{223,0x00,0x00},
+{224,0xF4,0x00},
+{225,0xF0,0x00},
+{226,0x00,0x00},
+{227,0x00,0x00},
+{228,0x00,0x00},
+{229,0x00,0x00},
+{231,0x00,0x00},
+{232,0x00,0x00},
+{233,0x00,0x00},
+{234,0x00,0x00},
+{235,0x00,0x00},
+{236,0x00,0x00},
+{237,0x00,0x00},
+{238,0x14,0x00},
+{239,0x00,0x00},
+{240,0x00,0x00},
+{242,0x02,0x02},
+{243,0xF0,0x00},
+{244,0x00,0x00},
+{245,0x00,0x00},
+{247,0x00,0x00},
+{248,0x00,0x00},
+{249,0xA8,0x00},
+{250,0x00,0x00},
+{251,0x84,0x00},
+{252,0x00,0x00},
+{253,0x00,0x00},
+{254,0x00,0x00},
+{255, 1, 0xFF}, // set page bit to 1 
+{  0,0x00,0x00},
+{  1,0x00,0x00},
+{  2,0x00,0x00},
+{  3,0x00,0x00},
+{  4,0x00,0x00},
+{  5,0x00,0x00},
+{  6,0x00,0x00},
+{  7,0x00,0x00},
+{  8,0x00,0x00},
+{  9,0x00,0x00},
+{ 10,0x00,0x00},
+{ 11,0x00,0x00},
+{ 12,0x00,0x00},
+{ 13,0x00,0x00},
+{ 14,0x00,0x00},
+{ 15,0x00,0x00},
+{ 16,0x00,0x00},
+{ 17,0x01,0x00},
+{ 18,0x00,0x00},
+{ 19,0x00,0x00},
+{ 20,0x90,0x00},
+{ 21,0x31,0x00},
+{ 22,0x00,0x00},
+{ 23,0x00,0x00},
+{ 24,0x01,0x00},
+{ 25,0x00,0x00},
+{ 26,0x00,0x00},
+{ 27,0x00,0x00},
+{ 28,0x00,0x00},
+{ 29,0x00,0x00},
+{ 30,0x00,0x00},
+{ 31,0x00,0xFF},
+{ 32,0x00,0xFF},
+{ 33,0x01,0xFF},
+{ 34,0x00,0xFF},
+{ 35,0x00,0xFF},
+{ 36,0x90,0xFF},
+{ 37,0x31,0xFF},
+{ 38,0x00,0xFF},
+{ 39,0x00,0xFF},
+{ 40,0x01,0xFF},
+{ 41,0x00,0xFF},
+{ 42,0x00,0xFF},
+{ 43,0x00,0x0F},
+{ 44,0x00,0x00},
+{ 45,0x00,0x00},
+{ 46,0x00,0x00},
+{ 47,0x00,0xFF},
+{ 48,0x00,0xFF},
+{ 49,0x01,0xFF},
+{ 50,0x00,0xFF},
+{ 51,0x00,0xFF},
+{ 52,0x90,0xFF},
+{ 53,0x31,0xFF},
+{ 54,0x00,0xFF},
+{ 55,0x00,0xFF},
+{ 56,0x01,0xFF},
+{ 57,0x00,0xFF},
+{ 58,0x00,0xFF},
+{ 59,0x00,0x0F},
+{ 60,0x00,0x00},
+{ 61,0x00,0x00},
+{ 62,0x00,0x00},
+{ 63,0x00,0xFF},
+{ 64,0x00,0xFF},
+{ 65,0x01,0xFF},
+{ 66,0x00,0xFF},
+{ 67,0x00,0xFF},
+{ 68,0x90,0xFF},
+{ 69,0x31,0xFF},
+{ 70,0x00,0xFF},
+{ 71,0x00,0xFF},
+{ 72,0x01,0xFF},
+{ 73,0x00,0xFF},
+{ 74,0x00,0xFF},
+{ 75,0x00,0x0F},
+{ 76,0x00,0x00},
+{ 77,0x00,0x00},
+{ 78,0x00,0x00},
+{ 79,0x00,0xFF},
+{ 80,0x00,0xFF},
+{ 81,0x00,0xFF},
+{ 82,0x00,0xFF},
+{ 83,0x00,0xFF},
+{ 84,0x90,0xFF},
+{ 85,0x31,0xFF},
+{ 86,0x00,0xFF},
+{ 87,0x00,0xFF},
+{ 88,0x01,0xFF},
+{ 89,0x00,0xFF},
+{ 90,0x00,0xFF},
+{ 91,0x00,0x0F},
+{ 92,0x00,0x00},
+{ 93,0x00,0x00},
+{ 94,0x00,0x00},
+{255, 0, 0xFF} }; // set page bit to 0
+//End of file
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h b/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h
new file mode 100644
index 0000000000..98fd41f8f4
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_define_te0803.h
@@ -0,0 +1,69 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+
+#ifndef SRC_TE_IIC_DEFINE_H_
+#define SRC_TE_IIC_DEFINE_H_
+
+/* Board specific settings - General example*/
+
+/* use own 'main' function */
+// #define TE_STANDALONE
+
+/* Define clock chip */
+// #define CLOCK_SI5345
+// #define NVM_CODE /* for SI5345: NVM writing is limited!,  you do it on your own risk!*/
+
+#define CLOCK_SI5338
+
+
+/* IIC interface type definition (use one that pass) */
+// #define IIC_TYPE_AXI_IIC
+// #define IIC_BASE_ADDRESS	XPAR_IIC_0_BASEADDR
+
+//#define IIC_TYPE_ZYNQPS_IIC
+//#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
+
+#define IIC_TYPE_ZYNQUPS_IIC
+#define XIICPS_DEVICE_ID	XPAR_XIICPS_0_DEVICE_ID
+
+//#define IIC_TYPE_MCS_GPIO_IIC
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+//#define IIC_TYPE_AXI_GPIO_IIC
+//#define GPIO_DEVICE_ID	XPAR_GPIO_0_DEVICE_ID
+//#define GPIO_CHANNEL	0
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+//#define IIC_TYPE_PS_GPIO_IIC
+//#define GPIO_DEVICE_ID	XPAR_XGPIOPS_0_DEVICE_ID
+//#define GPIO_SDA_PIN	0
+//#define GPIO_SCL_PIN	1
+
+/* Define IIC clock speed */
+#define IIC_SCLK_RATE			400000
+
+
+/* UART interface type definition (use one that pass) */
+
+// #define UART_TYPE_AXI_UARTLITE
+// #define UART_DEVICE_ID			XPAR_AXI_UARTLITE_0_DEVICE_ID
+
+//#define UART_TYPE_AXI_UART16550
+//#define UART_DEVICE_ID			XPAR_UARTNS550_0_DEVICE_ID
+
+//#define UART_TYPE_ZYNQPS_UART
+//#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
+
+#define UART_TYPE_ZYNQUPS_UART
+#define UART_DEVICE_ID			XPAR_XUARTPS_0_DEVICE_ID
+
+//#define UART_TYPE_NO_UART
+
+/* Define UART baudrate */
+#define UART_BAUDRATE			115200
+
+#endif /* SRC_TE_IIC_DEFINE_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c
new file mode 100644
index 0000000000..2f262b6958
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.c
@@ -0,0 +1,512 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#include "te_iic_platform.h"
+#include "te_uart.h"
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_IIC
+int iic_init(void)
+{
+	int Status;
+	u32 StatusReg;
+
+	/* Initialize the IIC Core. */
+	Status = XIic_DynInit(IIC_BASE_ADDRESS);
+	if (Status != XST_SUCCESS) {
+		p_printf(("IIC Controller Init failure\r\n"));
+		return XST_FAILURE;
+	}
+	/* Make sure all the Fifo's are cleared and Bus is Not busy. */
+	while (((StatusReg = XIic_ReadReg(IIC_BASE_ADDRESS,
+				XIIC_SR_REG_OFFSET)) &
+				(XIIC_SR_RX_FIFO_EMPTY_MASK |
+				XIIC_SR_TX_FIFO_EMPTY_MASK |
+				XIIC_SR_BUS_BUSY_MASK)) !=
+				(XIIC_SR_RX_FIFO_EMPTY_MASK |
+				XIIC_SR_TX_FIFO_EMPTY_MASK)) {
+	}
+	return Status;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+	int Status;
+	u8 SentByteCount;
+	u8 WriteBuffer[2];
+
+	WriteBuffer[0] = (u8) (reg_addr);
+	WriteBuffer[1] = (u8) (reg_val);
+	Status = XST_SUCCESS;
+
+	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, WriteBuffer, 2, XIIC_STOP);
+
+	if(SentByteCount != 2){	// All bits
+		Status = XST_FAILURE;
+	}
+	return Status;
+}
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val)
+{
+	u8 SentByteCount;
+	u8 ReceivedByteCount;
+	u8 WriteBuffer = reg_addr;
+
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read8: addr 0x%04x\r\n", reg_addr));
+	#endif
+	SentByteCount = XIic_DynSend(IIC_BASE_ADDRESS, chip_addr, &WriteBuffer, 1, XIIC_STOP);
+	if(SentByteCount != 1){
+		return XST_FAILURE;
+	}
+	ReceivedByteCount = XIic_DynRecv(IIC_BASE_ADDRESS, chip_addr, reg_val, 1);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read8: received %d bytes = 0x%02x\r\n", ReceivedByteCount, reg_val[0]));
+	#endif
+	if(ReceivedByteCount != 1){
+		return XST_FAILURE;
+	}
+	return XST_SUCCESS;
+}
+
+void iic_delay(int delay_ms){
+	volatile int i;
+	for(i=0;i<(delay_ms*1000000);i++);
+}
+
+#endif /* IIC_TYPE_AXI_IIC */
+
+/*----------------------------------------------------------------------------*/
+#if defined(IIC_TYPE_ZYNQPS_IIC) || defined(IIC_TYPE_ZYNQUPS_IIC)
+int iic_init(void)
+{
+	XIicPs_Config *I2cCfgPtr;
+	int Status = XST_SUCCESS;
+
+	I2cCfgPtr = XIicPs_LookupConfig(XIICPS_DEVICE_ID);
+
+	if (I2cCfgPtr == NULL){
+		p_printf(("IIC Controller lookup failure\r\n"));
+		return XST_FAILURE;
+	}
+
+	Status = XIicPs_CfgInitialize(&I2cInstancePtr, I2cCfgPtr, I2cCfgPtr->BaseAddress);
+	if (Status != XST_SUCCESS) {
+		p_printf(("IIC Controller Init failure\r\n"));
+		return XST_FAILURE;
+	}
+
+	XIicPs_SetSClk(&I2cInstancePtr, IIC_SCLK_RATE);
+	return Status;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+    u8 WriteBuffer[10];
+	int Status;
+
+	WriteBuffer[0] = reg_addr;
+	WriteBuffer[1] = reg_val;
+    Status = XIicPs_MasterSendPolled(&I2cInstancePtr, WriteBuffer, 2, chip_addr);
+    if (Status != XST_SUCCESS) {
+		return Status;
+    }
+
+    // Wait until bus is idle to start another transfer
+    while (XIicPs_BusIsBusy(&I2cInstancePtr)) {};
+
+	return XST_SUCCESS;
+}
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
+{
+	u8 wr_data;
+	wr_data = reg_addr;
+	XIicPs_MasterSendPolled(&I2cInstancePtr, &wr_data, 1, chip_addr);
+	XIicPs_MasterRecvPolled(&I2cInstancePtr, data, 1, chip_addr);
+	while (XIicPs_BusIsBusy(&I2cInstancePtr));
+	return 0;
+}
+
+void iic_delay(int delay_ms){
+	usleep(delay_ms*1000);
+}
+
+#endif /* IIC_TYPE_ZYNQPS_IIC IIC_TYPE_ZYNQUPS_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_MCS_GPIO_IIC
+
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	static unsigned int gpio_shadow = 0;
+	if(value == 0)
+	{
+		gpio_shadow &= ~(1 << pin);
+	}
+	else
+	{
+		gpio_shadow |= (1 << pin);
+	}
+	XIo_Out32(GPIO_OUT_REG, gpio_shadow);
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if((XIo_In32(GPIO_IN_REG) & (1 << pin)) != 0)
+	{
+		return 1;
+	}
+	return 0; 
+}
+
+int iic_init(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 1);
+	gpio_set_pin(GPIO_SCL_PIN, 1);
+  return 0; 
+}
+
+#endif /* IIC_TYPE_MCS_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_GPIO_IIC
+int iic_init(void)
+{
+	int Status;
+	u32 dir;
+	Status = XGpio_Initialize(&Gpio, GPIO_DEVICE_ID);
+	// SCL and SDA should have PULL UP
+	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
+	dir |= (GPIO_SDA_PIN | GPIO_SCL_PIN);
+	// Set Direction to IN
+	XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	// Set Values to 0
+	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SDA_PIN);
+	XGpio_DiscreteClear(&Gpio, GPIO_CHANNEL, GPIO_SCL_PIN);
+
+	return Status;
+}
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	u32 dir;
+	dir = XGpio_GetDataDirection(&Gpio, GPIO_CHANNEL);
+	if(value == 0){	// Set direction to OUT
+		dir &= ~value;
+		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	}
+	else{			// Set direction to IN
+		dir |= value;
+		XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, dir);
+	}
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if(XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) | pin){
+		return 1;
+	}
+	else{
+		return 0;
+	}
+}
+
+#endif /* IIC_TYPE_AXI_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_PS_GPIO_IIC
+
+int iic_init(void)
+{
+	int Status;
+	XGpioPs_Config *ConfigPtr;
+
+	ConfigPtr = XGpioPs_LookupConfig(GPIO_DEVICE_ID);
+	Status = XGpioPs_CfgInitialize(&Gpio, ConfigPtr, ConfigPtr->BaseAddr);
+	// Set Direction to IN
+	XGpioPs_SetDirectionPin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_SetDirectionPin(&Gpio, GPIO_SCL_PIN, 0);
+	// Output disable
+	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_SetOutputEnablePin(&Gpio, GPIO_SCL_PIN, 0);
+	// Set Values to 0
+	XGpioPs_WritePin(&Gpio, GPIO_SDA_PIN, 0);
+	XGpioPs_WritePin(&Gpio, GPIO_SCL_PIN, 0);
+
+	return Status;
+}
+
+void gpio_set_pin(unsigned int pin, unsigned int value)
+{
+	if(value == 0){	// Set direction to OUT
+		// Set Direction to IN
+		XGpioPs_SetDirectionPin(&Gpio, value, 1);
+		// Output enable
+		XGpioPs_SetOutputEnablePin(&Gpio, value, 1);
+	}
+	else{			// Set direction to IN
+		// Set Direction to IN
+		XGpioPs_SetDirectionPin(&Gpio, value, 0);
+		// Output disable
+		XGpioPs_SetOutputEnablePin(&Gpio, value, 0);
+	}
+}
+
+u8 gpio_get_pin(unsigned int pin)
+{
+	if(XGpioPs_ReadPin(&Gpio, Output_Pin) | pin)
+	{
+		return 1;
+	}
+	else{
+		return 0;
+	}
+}
+
+#endif /* IIC_TYPE_PS_GPIO_IIC */
+
+/*----------------------------------------------------------------------------*/
+/* Common functions for all GPIOs implementation */
+#if defined(IIC_TYPE_MCS_GPIO_IIC) || defined(IIC_TYPE_AXI_GPIO_IIC) || defined(IIC_TYPE_PS_GPIO_IIC)
+
+void iic_dly(){
+	volatile int i;
+	for(i=0;i<(1000);i++){
+	}
+}
+
+void iic_delay(int delay_ms){
+	volatile int i;
+	for(i=0;i<(delay_ms*1000000);i++);
+}
+
+void iic_start(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	gpio_set_pin(GPIO_SDA_PIN, 0);	// pull SDA low
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// pull SCL low
+	iic_dly();
+}
+
+void iic_stop(void)
+{
+	gpio_set_pin(GPIO_SDA_PIN, 0);	// Pull SDA low
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure SCL low
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+	iic_dly();
+}
+
+void iic_send_bit(u8 value)
+{
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
+	gpio_set_pin(GPIO_SDA_PIN, value);	// Set data
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+}
+
+u8 iic_receive_bit()
+{
+	u8 rcv_data;
+	
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Ensure that SCL is low
+	gpio_set_pin(GPIO_SDA_PIN, 1);	// Pull SDA High 
+	iic_dly();
+	gpio_set_pin(GPIO_SCL_PIN, 1);	// Pull SCL High 
+	iic_dly();
+	rcv_data = gpio_get_pin(GPIO_SDA_PIN);
+	gpio_set_pin(GPIO_SCL_PIN, 0);	// Pull SCL low
+	return rcv_data;
+}
+
+u8 iic_write(u8 value)
+{
+	u8 i;
+	u8 shifter = value;
+	
+	for(i = 0; i < 8; i++)
+	{
+		iic_send_bit(shifter >> 7);
+		shifter = shifter << 1;
+	}
+	return iic_receive_bit();
+}
+
+u8 iic_read(u8 ack)
+{
+	u8 i, shifter;
+	
+	for (i = 0; i < 8; i++)		// loop through each bit
+	{
+		shifter = shifter << 1;
+		shifter |= iic_receive_bit();
+	}
+	iic_send_bit(ack);			// Send ACK/NACK
+	return shifter;
+}
+
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val)
+{
+	int Status = 0;
+	
+	iic_start();
+	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_addr);			// Register address
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_val);			// Register data
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	iic_stop();
+	return 0;
+}
+
+
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *data)
+{
+	int Status = 0;
+	
+	iic_start();
+	Status = iic_write(chip_addr << 1);		// Chip addr & Write 
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	Status = iic_write(reg_addr);			// Register address
+	if(Status != 0)							// No ACK from chip
+	{
+		p_printf(("IIC Write: no ACK from Slave\r\n"));
+		return 1;
+	}
+	iic_start();							// Repeated start
+	Status = iic_write((chip_addr << 1) | 0x01);	// Chip addr & Read
+	if(Status != 0)							// No ACK from chip
+	{
+		return 1;
+	}
+	*data = iic_read(1);						// NACK
+	iic_stop();
+	return 0;
+}
+
+#endif
+
+/*----------------------------------------------------------------------------*/
+/* Platform independent functions */
+int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask)
+{
+	int Status;
+	u8 rd_val;
+
+	if(mask == 0xFF){				// All bits
+		iic_write8(chip_addr, reg_addr, reg_val);
+	}
+	else{							// Write by mask
+		Status = iic_read8(chip_addr, reg_addr, &rd_val);
+		if(Status != XST_SUCCESS){
+			return Status;
+		}
+		rd_val &= ~mask;			// Clear bits to write
+		rd_val |= reg_val & mask;	// Set bits by mask
+		Status = iic_write8(chip_addr, reg_addr, rd_val);
+		if(Status != XST_SUCCESS){
+			return Status;
+		}
+	}
+	return XST_SUCCESS;
+}
+
+int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val)
+{
+	int Status;
+	u8 page, addr;
+	static int _last_page = -1;
+
+	page = (u8) (reg_addr >> 8);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_write16: addr 0x%04x data 0x%02x page 0x%02x (0x%02x) addr 0x%02x [%d]\r\n", reg_addr, reg_val, page, _last_page, (reg_addr & 0xFF), total++));
+	#endif
+
+	if (_last_page < 0 || _last_page != page) {		// New page
+		#ifdef DEBUG_MSG
+		p_printf(("p\r\n"));
+		#endif
+		Status = iic_write8(chip_addr, 0x01, page);
+		if (Status != XST_SUCCESS) {
+			p_printf(("iic_write16 page write failure\r\n"));
+			return XST_FAILURE;
+		}
+	}
+	_last_page = page;
+
+	#ifdef DEBUG_MSG
+	p_printf(("r\r\n"));
+	#endif
+	addr = (u8) reg_addr & 0xFF;
+	Status = iic_write8(chip_addr, addr, reg_val);
+	if (Status != XST_SUCCESS) {
+		p_printf(("iic_write16 reg write failure\r\n"));
+		return XST_FAILURE;
+	}
+	return Status;
+}
+
+int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val)
+{
+	int Status;
+	u8 page, addr;
+	static int _last_page = -1;
+
+	page = (u8) (reg_addr >> 8);
+	#ifdef DEBUG_MSG
+	p_printf(("iic_read16: addr 0x%04x page 0x%02x (0x%02x) addr 0x%02x\r\n", reg_addr, page, _last_page, (reg_addr & 0xFF)));
+	#endif
+
+	if (_last_page < 0 || _last_page != page) {		// New page
+		#ifdef DEBUG_MSG
+		p_printf(("p\r\n"));
+		#endif
+		Status = iic_write8(chip_addr, 0x01, page);
+		if (Status != XST_SUCCESS) {
+			p_printf(("iic_read16 page write failure\r\n"));
+			return XST_FAILURE;
+		}
+	}
+	_last_page = page;
+
+	#ifdef DEBUG_MSG
+	p_printf(("r\r\n"));
+	#endif
+	addr = (u8) reg_addr & 0xFF;
+	Status = iic_read8(chip_addr, addr, reg_val);
+	if (Status != XST_SUCCESS) {
+		p_printf(("iic_read16 reg read failure\r\n"));
+		return XST_FAILURE;
+	}
+	return Status;
+}
+/*----------------------------------------------------------------------------*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h
new file mode 100644
index 0000000000..fdacfe1b28
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_iic_platform.h
@@ -0,0 +1,62 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef IIC_PLATFORM_H_
+#define IIC_PLATFORM_H_
+#include "xparameters.h"
+
+/* Include board specific settings */
+// #include "te_iic_define.h"
+#include "te_iic_define_te0803.h"
+// #include "te_iic_define_te0820.h"
+// #include "te_iic_define_te0712.h"
+
+/* Enable extra Debug messages */
+//#define DEBUG_MSG
+/*----------------------------------------------------------------------------*/
+int iic_init(void);
+int iic_write8(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val);
+int iic_read8(unsigned char chip_addr, unsigned char reg_addr, unsigned char *reg_val);
+int iic_write8_mask(unsigned char chip_addr, unsigned char reg_addr, unsigned char reg_val, unsigned char mask);
+int iic_write16(unsigned char chip_addr, unsigned short reg_addr, unsigned char reg_val);
+int iic_read16(unsigned char chip_addr, unsigned short reg_addr, unsigned char *reg_val);
+void iic_delay(int delay_ms);
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_IIC
+#include "xiic.h"
+#endif /* IIC_TYPE_AXI_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_ZYNQPS_IIC
+#include "xiicps.h"
+#include <unistd.h>
+#include <stdio.h>
+XIicPs I2cInstancePtr;
+#endif /* IIC_TYPE_ZYNQPS_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_ZYNQUPS_IIC
+#include "xiicps.h"
+#include <sleep.h>
+#include <stdio.h>
+XIicPs I2cInstancePtr;
+#endif /* IIC_TYPE_ZYNQUPS_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_MCS_GPIO_IIC
+#include "xiomodule_l.h"
+#include "xstatus.h"
+#include "xio.h"
+#define GPIO_OUT_REG	XPAR_IOMODULE_SINGLE_BASEADDR + XGO_OUT_OFFSET
+#define GPIO_IN_REG		XPAR_IOMODULE_SINGLE_BASEADDR + XGI_IN_OFFSET
+#endif /* IIC_TYPE_MCS_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_AXI_GPIO_IIC
+#include "xgpio.h"
+XGpio Gpio;
+#endif /* IIC_TYPE_AXI_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#ifdef IIC_TYPE_PS_GPIO_IIC
+#include "xgpiops.h"
+XGpioPs Gpio;
+#endif /* IIC_TYPE_PS_GPIO_IIC */
+/*----------------------------------------------------------------------------*/
+#endif /* IIC_PLATFORM_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_si5338.c b/lib/sw_apps/zynqmp_fsbl/src/te_si5338.c
new file mode 100644
index 0000000000..dddb7cfd15
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_si5338.c
@@ -0,0 +1,152 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+
+#include "te_si5338.h"
+
+#ifdef CLOCK_SI5338
+#include "te_uart.h"
+#include "te_Si5338-Registers.h"
+
+#define DELAY_AFTER_PLL_CONFIG_US	0x100000U 
+
+int si5338_version(unsigned char chip_addr){
+	u8 reg_val;
+	int Status;
+  
+    Status = iic_read8( chip_addr, 2, &reg_val);
+    xil_printf("SI53%i",reg_val);
+    Status = iic_read8( chip_addr, 0, &reg_val);
+    if (reg_val==0) {
+      xil_printf("-A\r\n");
+    } else if (reg_val==1) {
+      xil_printf("-B\r\n");
+    } else {
+      xil_printf("-%x\r\n",reg_val);
+    }
+
+	  return Status;
+}
+
+int si5338_status_wait(unsigned char chip_addr){
+	u8 reg_val;
+	unsigned int  cnt=0, tmp;
+	int Status;
+  
+  (void)usleep(0x5U);
+  Status = iic_read8( chip_addr, 218, &reg_val);
+  
+  tmp = 1;
+  // Wait until internal calibration is not busy
+  while (tmp ==1) {
+    cnt=cnt+0x100U ;
+    (void)usleep(0x100U);
+    Status = iic_read8( chip_addr, 218, &reg_val);
+    tmp =((reg_val) & (0x01));
+    
+    if ((cnt % 0x100U) == 0) {
+      xil_printf("Status 218:0x%x (...waiting for calibration...%i us).\r",reg_val,cnt);
+    }
+    
+    if (cnt >= TIME_CHECK_PLL_CONFIG_US) {
+        xil_printf("Status 218:0x%x (...calibration not finished after %i us...exit...).\r\n",reg_val,cnt);
+        xil_printf("Status 218:0x%x (cal bit0:%i) will be checked one time again after %i us\r\n",reg_val,tmp,DELAY_AFTER_PLL_CONFIG_US);
+        tmp = 0;
+    }
+    
+  }
+   //sleep need for PCIe
+  (void)usleep(DELAY_AFTER_PLL_CONFIG_US);
+    
+  Status = iic_read8( chip_addr, 218, &reg_val);
+  xil_printf("PLL Status Register 218:0x%x                                         \r\n",reg_val);
+
+	  return Status;
+}
+
+
+
+int si5338_init(unsigned char chip_addr)
+{
+	int i;
+	u8 reg_val;
+	Reg_Data rd;
+	int Status;
+  
+#ifdef DEBUG_REG
+  u8 readback_test;
+#endif
+
+    // p_printf(("Si5338 Init Start.\r\n"));
+    // iic_init();
+    p_printf(("Si5338 Init Registers Write.\r\n"));
+
+	// I2C Programming Procedure
+	iic_write8( chip_addr, 246, 0x01);					//Hard reset
+	// Disable Outputs
+	iic_write8_mask( chip_addr, 230, EOB_ALL, EOB_ALL);	// EOB_ALL = 1
+	// Pause LOL
+	iic_write8_mask( chip_addr, 241, DIS_LOL, DIS_LOL);	// DIS_LOL = 1
+	// Write new configuration to device accounting for the write-allowed mask
+	for(i=0; i<NUM_REGS_MAX; i++){
+		rd = Reg_Store[i];
+		iic_write8_mask( chip_addr, rd.Reg_Addr, rd.Reg_Val, rd.Reg_Mask);
+    #ifdef DEBUG_REG
+      Status = iic_read8( chip_addr ,rd.Reg_Addr, &readback_test);
+      if(Status != XST_SUCCESS) {
+        p_printf(("si5338_init: Can't read register\r\n"));
+        return Status;
+      }
+      if (rd.Reg_Val != readback_test) {
+        p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X  ----- Difference detected please check.\r\n",rd.Reg_Addr, rd.Reg_Addr, readback_test));
+      } else {
+        p_printf(("address 0x%04X: Write 0x%02X to  and read 0x%02X.\r\n",rd.Reg_Addr, rd.Reg_Addr, readback_test));
+      }
+    #endif
+	}
+	// Validate clock input status
+//	reg_val = iic_read8( chip_addr , 218) & LOS_MASK;
+	do{
+		Status = iic_read8( chip_addr , 218, &reg_val);
+        if(Status != XST_SUCCESS) {
+            p_printf(("si5338_init: Can't read register\r\n"));
+            return Status;
+        }
+	}
+	while((reg_val & LOS_MASK) != 0);
+
+	// Configure PLL for locking
+	iic_write8_mask( chip_addr, 49, 0, FCAL_OVRD_EN);	//FCAL_OVRD_EN = 0
+	// Initiate Locking of PLL
+	iic_write8( chip_addr, 246, SOFT_RESET);			//SOFT_RESET = 1
+	iic_delay(25);											// Wait 25 ms
+	// Restart LOL
+	iic_write8_mask( chip_addr, 241, 0, DIS_LOL);		// DIS_LOL = 0
+	iic_write8( chip_addr, 241, 0x65);				// Set reg 241 = 0x65
+	// Confirm PLL lock status
+	do{
+		Status = iic_read8( chip_addr, 218, &reg_val);
+        if(Status != XST_SUCCESS) {
+            p_printf(("si5338_init: Can't read register\r\n"));
+            return Status;
+        }
+	}
+	while((reg_val & LOCK_MASK) != 0);
+	//copy FCAL values to active registers
+	Status = iic_read8( chip_addr, 237, &reg_val);
+	iic_write8_mask( chip_addr, 47, reg_val, 0x03);	// 237[1:0] to 47[1:0]
+	Status = iic_read8( chip_addr, 236, &reg_val);
+	iic_write8( chip_addr, 46, reg_val);	// 236[7:0] to 46[7:0]
+	Status = iic_read8( chip_addr, 235, &reg_val);
+	iic_write8( chip_addr, 45, reg_val);	// 235[7:0] to 45[7:0]
+	iic_write8_mask( chip_addr, 47, 0x14, 0xFC);		// Set 47[7:2] = 000101b
+	// Set PLL to use FCAL values
+	iic_write8_mask( chip_addr, 49, FCAL_OVRD_EN, FCAL_OVRD_EN);	//FCAL_OVRD_EN = 1
+	// Enable Outputs
+	iic_write8( chip_addr, 230, 0x00);					//EOB_ALL = 0
+    p_printf(("Si5338 Init Complete\r\n"));
+	return XST_SUCCESS;
+}
+
+#endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_si5338.h b/lib/sw_apps/zynqmp_fsbl/src/te_si5338.h
new file mode 100644
index 0000000000..859665628c
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_si5338.h
@@ -0,0 +1,44 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+
+#ifndef SRC_SI5338_H_
+#define SRC_SI5338_H_
+
+#define code
+
+#include "te_iic_platform.h"
+#ifdef CLOCK_SI5338
+
+
+// #define SI5338_CHIP_ADDR		0x70
+
+#define TEST_REG_ADDR			0x00
+
+#define LOS_MASK_IN1IN2IN3		0x04
+#define LOS_MASK				LOS_MASK_IN1IN2IN3
+#define PLL_LOL					0x10
+#define LOS_FDBK				0x08
+#define LOS_CLKIN				0x04
+#define SYS_CAL					0x01
+#define LOCK_MASK				(PLL_LOL | LOS_CLKIN | SYS_CAL)
+#define FCAL_OVRD_EN			0x80
+#define SOFT_RESET				0x02
+#define EOB_ALL					0x10
+#define DIS_LOL					0x80
+
+//enable register read back and printf
+//#define DEBUG_REG	
+
+//max delay for calibration from SI documentation 300ms
+#define TIME_CHECK_PLL_CONFIG_US	0x50000U
+//delay
+#define DELAY_AFTER_PLL_CONFIG_US	0x20000U 
+
+int si5338_version(unsigned char chip_addr);
+int si5338_status_wait(unsigned char chip_addr);
+int si5338_init(unsigned char chip_addr);
+
+#endif /* CLOCK_SI5338 */
+#endif /* SRC_SI5338_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_uart.c b/lib/sw_apps/zynqmp_fsbl/src/te_uart.c
new file mode 100644
index 0000000000..d93472dc5c
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_uart.c
@@ -0,0 +1,47 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#include "te_uart.h"
+
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UARTLITE
+u8 uart_read_char(void){
+	u8 u;
+    XUartLite_Initialize(&UartLite, UART_DEVICE_ID);
+    while(!XUartLite_Recv(&UartLite, &u, 1)){
+    }
+	return u;
+}
+#endif /* UART_TYPE_AXI_UARTLITE */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UART16550
+u8 uart_read_char(void){
+	u8 u;
+	XUartNs550_Initialize(&UartNs550, UART_DEVICE_ID);
+	XUartNs550_SetBaudRate(&UartNs550, UART_BAUDRATE);
+    while(!XUartNs550_Recv(&UartNs550, &u, 1)){
+    }
+	return u;
+}
+#endif /* UART_TYPE_AXI_UART16550 */
+/*----------------------------------------------------------------------------*/
+#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
+u8 uart_read_char(void){
+	u8 u;
+	XUartPs_Config *Config;
+	Config = XUartPs_LookupConfig(UART_DEVICE_ID);
+	XUartPs_CfgInitialize(&Uart_Ps, Config, Config->BaseAddress);
+	XUartPs_SetBaudRate(&Uart_Ps, UART_BAUDRATE);
+	while(!XUartPs_Recv(&Uart_Ps, &u, 1)){
+	}
+	return u;
+}
+#endif /* UART_TYPE_ZYNQPS_UART */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_NO_UART
+u8 uart_read_char(void){
+	return 0;
+}
+#endif /* UART_TYPE_NO_UART */
+/*----------------------------------------------------------------------------*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_uart.h b/lib/sw_apps/zynqmp_fsbl/src/te_uart.h
new file mode 100644
index 0000000000..f6dc11edf1
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_uart.h
@@ -0,0 +1,40 @@
+/*
+-- Company: 		Trenz Electronic
+-- Engineer: 		Oleksandr Kiyenko / John Hartfiel
+ */
+#ifndef SRC_TE_UART_H_
+#define SRC_TE_UART_H_
+
+#include "te_iic_platform.h"
+
+u8 uart_read_char(void);
+
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UARTLITE
+#include "xil_printf.h"
+#include "xuartlite.h"
+#define p_printf(x)	xil_printf x
+XUartLite UartLite;
+#endif /* UART_TYPE_AXI_UARTLITE */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_AXI_UART16550
+#include "xil_printf.h"
+#include "xuartns550.h"
+#include "xuartns550_i.h"
+#define p_printf(x)	xil_printf x
+XUartNs550 UartNs550;
+#endif /* UART_TYPE_AXI_UART16550 */
+/*----------------------------------------------------------------------------*/
+#if defined(UART_TYPE_ZYNQPS_UART) || defined(UART_TYPE_ZYNQUPS_UART)
+#include "xil_printf.h"
+#include "xuartps.h"
+#define p_printf(x)	xil_printf x
+XUartPs Uart_Ps;
+#endif /* UART_TYPE_ZYNQPS_UART */
+/*----------------------------------------------------------------------------*/
+#ifdef UART_TYPE_NO_UART
+#define p_printf(x)
+#endif /* UART_TYPE_NO_UART */
+/*----------------------------------------------------------------------------*/
+
+#endif /* SRC_TE_UART_H_ */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.c b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.c
new file mode 100644
index 0000000000..811729a127
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.c
@@ -0,0 +1,171 @@
+/******************************************************************************
+*
+* 
+*
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file te_xfsbl_hooks.c
+
+******************************************************************************/
+/***************************** Include Files *********************************/
+#include "te_xfsbl_hooks.h"
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+u32 TE_XFsbl_HookBeforeBSDownload(void )
+{
+	u32 Status = XFSBL_SUCCESS;
+
+	/**
+	 * Add the code here
+	 */
+#if defined(ENABLE_TE_HOOKS_BD)
+	Status = TE_XFsbl_HookBeforeBSDownload_Custom();
+#endif  
+
+	return Status;
+}
+
+
+u32 TE_XFsbl_HookAfterBSDownload(void )
+{
+	u32 Status = XFSBL_SUCCESS;
+
+	/**
+	 * Add the code here
+	 */
+#if defined(ENABLE_TE_HOOKS_AD)
+	Status = TE_XFsbl_HookAfterBSDownload_Custom();
+#endif  
+
+	return Status;
+}
+
+u32 TE_XFsbl_HookBeforeHandoff(u32 EarlyHandoff)
+{
+	u32 Status = XFSBL_SUCCESS;
+
+	/**
+	 * Add the code here
+	 */
+#if defined(ENABLE_TE_HOOKS_BH)
+	Status = TE_XFsbl_HookBeforeHandoff_Custom(EarlyHandoff);
+#endif  
+
+	return Status;
+}
+
+/*****************************************************************************/
+/**
+ * This is a hook function where user can include the functionality to be run
+ * before FSBL fallback happens
+ *
+ * @param none
+ *
+ * @return error status based on implemented functionality (SUCCESS by default)
+ *
+  *****************************************************************************/
+
+u32 TE_XFsbl_HookBeforeFallback(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+
+	/**
+	 * Add the code here
+	 */
+#if defined(ENABLE_TE_HOOKS_BF)
+	Status = TE_XFsbl_HookBeforeFallback_Custom();
+#endif  
+
+	return Status;
+}
+
+/*****************************************************************************/
+/**
+ * This function facilitates users to define different variants of psu_init()
+ * functions based on different configurations in Vivado. The default call to
+ * psu_init() can then be swapped with the alternate variant based on the
+ * requirement.
+ *
+ * @param none
+ *
+ * @return error status based on implemented functionality (SUCCESS by default)
+ *
+  *****************************************************************************/
+#if defined(ENABLE_TE_HOOKS_PSU)  
+# else 
+u32 TE_XFsbl_PSU_Default(void)
+{
+  //copy from Xilinx default PSU, xilinx default PSU from Xilinx xfsbl_hooks must be deactivated when TE modified variant is used
+    u32 Status;
+  #ifdef XFSBL_ENABLE_DDR_SR
+    u32 RegVal;
+  #endif
+    
+  #ifdef XFSBL_ENABLE_DDR_SR
+    /* Check if DDR is in self refresh mode */
+    RegVal = Xil_In32(XFSBL_DDR_STATUS_REGISTER_OFFSET) &
+      DDR_STATUS_FLAG_MASK;
+    if (RegVal) {
+      Status = (u32)psu_init_ddr_self_refresh();
+    } else {
+      Status = (u32)psu_init();
+    }
+  #else
+    Status = (u32)psu_init();
+  #endif
+  
+  	return Status;
+}
+#endif  
+
+
+u32 TE_XFsbl_HookPsuInit(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+
+	/* Add the code here */
+#if defined(ENABLE_TE_HOOKS_PSU)
+	Status = TE_XFsbl_HookPsuInit_Custom();
+# else 
+   Status = TE_XFsbl_PSU_Default();
+#endif  
+
+	return Status;
+}
+
+
+
+/***for xsfbl_board.h***/
+/*****************************************************************************/
+/**
+ * This function does board specific initialization.
+ * If there isn't any board specific initialization required, it just returns.
+ *
+ * @param none
+ *
+ * @return
+ * 		- XFSBL_SUCCESS for successful configuration
+ * 		- errors as mentioned in xfsbl_error.h
+ *
+ *****************************************************************************/
+u32 TE_XFsbl_BoardInit(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+  
+#if defined(ENABLE_TE_BOARD)
+	Status = TE_XFsbl_BoardInit_Custom();
+#endif  
+  
+
+	return Status;
+}
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h
new file mode 100644
index 0000000000..cdf46996c3
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks.h
@@ -0,0 +1,62 @@
+/******************************************************************************
+*
+* 
+*
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file te_xfsbl_hooks.h
+*
+*
+******************************************************************************/
+#ifndef TE_XFSBL_HOOKS_H
+#define TE_XFSBL_HOOKS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "xil_types.h"
+#include "xfsbl_hw.h"
+// rename and enable custom TE hooks
+#include "te_xfsbl_hooks_te0803.h"
+
+#define ENABLE_TE_HOOKS_PSU //TE_XFsbl_HookPsuInit
+#define ENABLE_TE_BOARD // TE_XFsbl_BoardInit
+// #define ENABLE_TE_HOOKS_BD //TE_XFsbl_HookBeforeBSDownload
+// #define ENABLE_TE_HOOKS_AD //TE_XFsbl_HookAfterBSDownload
+// #define ENABLE_TE_HOOKS_BH //TE_XFsbl_HookBeforeHandoff
+// #define ENABLE_TE_HOOKS_BF // TE_XFsbl_HookBeforeFallback
+
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+// for xsfbl_hooks.h/c
+u32 TE_XFsbl_HookBeforeBSDownload(void );
+
+u32 TE_XFsbl_HookAfterBSDownload(void );
+
+u32 TE_XFsbl_HookBeforeHandoff(u32 EarlyHandoff);
+
+u32 TE_XFsbl_HookBeforeFallback(void);
+
+u32 TE_XFsbl_HookPsuInit(void);
+
+// for xsfbl_board.h/c
+u32 TE_XFsbl_BoardInit(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* XFSBL_HOOKS_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c
new file mode 100644
index 0000000000..aa5c6a6623
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.c
@@ -0,0 +1,402 @@
+/******************************************************************************
+*
+* 
+*
+
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file te_xfsbl_hooks.c
+
+******************************************************************************/
+/***************************** Include Files *********************************/
+//rename to correct board name
+#include "te_xfsbl_hooks_te0803.h"
+
+#include "psu_init.h"
+/************************** Constant Definitions *****************************/
+
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+u32 TE_XFsbl_HookBeforeBSDownload_Custom(void )
+{
+	u32 Status = XFSBL_SUCCESS;
+
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+    xil_printf("TE0803 TE_XFsbl_HookBeforeBSDownload_Custom\r\n"); 
+	/* Add the code here */
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+	return Status;
+}
+
+
+u32 TE_XFsbl_HookAfterBSDownload_Custom(void )
+{
+	u32 Status = XFSBL_SUCCESS;
+
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+    xil_printf("TE0803 TE_XFsbl_HookAfterBSDownload_Custom\r\n"); 
+	/* Add the code here */
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+    return Status;
+}
+
+u32 TE_XFsbl_HookBeforeHandoff_Custom(u32 EarlyHandoff)
+{
+	u32 Status = XFSBL_SUCCESS;
+
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+    xil_printf("TE0803 TE_XFsbl_HookBeforeHandoff_Custom\r\n"); 
+	/* Add the code here */
+    xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+    return Status;
+}
+
+/*****************************************************************************/
+/**
+ * This is a hook function where user can include the functionality to be run
+ * before FSBL fallback happens
+ *
+ * @param none
+ *
+ * @return error status based on implemented functionality (SUCCESS by default)
+ *
+  *****************************************************************************/
+
+u32 TE_XFsbl_HookBeforeFallback_Custom(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+
+
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0803 TE_XFsbl_HookBeforeFallback_Custom\r\n"); 
+	/* Add the code here */
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+	return Status;
+}
+
+/*****************************************************************************/
+/**
+ * This function facilitates users to define different variants of psu_init()
+ * functions based on different configurations in Vivado. The default call to
+ * psu_init() can then be swapped with the alternate variant based on the
+ * requirement.
+ *
+ * @param none
+ *
+ * @return error status based on implemented functionality (SUCCESS by default)
+ *
+  *****************************************************************************/
+#ifdef USE_TE_PSU_FOR_SI_INIT
+ u32 TE_XFsbl_TPSU_MODIFIED(void)
+{
+  // note Xilinx PSU must be disabled in tx_xfsbl_hooks.h
+  // used to configure SI on the module. Only needed on this stage if SI CLKs are used for PS
+  u32 Status;
+
+  u32 DDRRegVal = 0;
+  #ifdef XFSBL_ENABLE_DDR_SR
+    /* Check if DDR is in self refresh mode */
+    DDRRegVal = Xil_In32(XFSBL_DDR_STATUS_REGISTER_OFFSET) &
+      DDR_STATUS_FLAG_MASK;
+  #endif
+  //Status = (u32)psu_init(); --> replace with inner code from psu_init
+  // code from psu_init():  
+  int psu_status = 1;
+
+  psu_status &= psu_mio_init_data();
+  psu_status &=  psu_peripherals_pre_init_data();
+  psu_status &=   psu_pll_init_data();
+  psu_status &=   psu_clock_init_data();
+  psu_status &=  psu_ddr_init_data();
+  
+
+  // modified to use same code for DDR with and without self refresh mode, diff between  psu_init_ddr_self_refresh and psu_init
+  if (DDRRegVal) {
+    //do nothing
+  } else {
+    psu_status &=  psu_ddr_phybringup_data();  // not used on XFSBL_ENABLE_DDR_SR
+  }
+  
+  psu_status &=  psu_peripherals_init_data();
+  
+  if (psu_status == 0) {
+    Status= psu_status;
+    // exit on error
+    goto END;
+  }
+
+  
+  //add code to initialize SI on module for GTR periphery
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0803 TE_XFsbl_HookPsuInit_Custom\r\n"); 
+  /* Add the code here */
+  // ------------------------------------------------------
+  // reset PCI and USB
+  	u32 dataVal = 0;
+
+    // USB reset  
+		/* Set MIO30 direction as output */
+    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO30_MASK);
+
+		/* Set MIO30 output enable */
+    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO30_MASK);  
+    
+    /* Set MIO30 to LOW */
+		dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO30_MASK);
+		XFsbl_Out32(GPIO_DATA_1, dataVal);
+    
+    // pcie reset
+    /* Set MIO31 direction as output */
+    XFsbl_Out32(GPIO_DIRM_1, XFsbl_In32(GPIO_DIRM_1) | GPIO_MIO31_MASK);
+
+    /* Set MIO31 output enable */
+    XFsbl_Out32(GPIO_OEN_1, XFsbl_In32(GPIO_OEN_1) | GPIO_MIO31_MASK);
+
+
+    /* Set MIO31 to LOW */
+    dataVal = XFsbl_In32(GPIO_DATA_1) & ~(GPIO_MIO31_MASK);
+    XFsbl_Out32(GPIO_DATA_1, dataVal);
+
+  // ------------------------------------------------------
+  Status = iic_init();                      // Configure I2C Bus 0 driver instance
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error:I2C Init\r\n");
+     goto END;
+  }
+  // change I2C switch to get access to SI5345
+  xil_printf("Configure Carrier I2C Switch 0x77\r\n");
+  Status = iic_write8(0x77, 0x00,  0x10);    // Configure I2C Switch
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: Configure TEBF0808 I2C Switch 0x77 for TE0803 SI5338 access\r\n");
+     goto END;
+  }
+  
+  xil_printf("Configure PLL: ");
+
+  Status= si5338_version(0x70);
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: Read Version of PLL\r\n");
+     goto END;
+  }
+  
+  Status = si5338_init(0x70);                      // Configure clocks
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: Configure CLK\r\n");
+     goto END;
+  }
+  Status= si5338_status_wait(0x70);
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: Read Status of PLL and wait for calibration\r\n");
+     goto END;
+  }
+  
+  // ------------------------------------------------------
+  // release PCI and USB reset
+  /* Set MIO30 to HIGH */
+  dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO30_MASK;
+  XFsbl_Out32(GPIO_DATA_1, dataVal);
+  xil_printf("USB Reset Complete \r\n");
+  
+
+  /* Set MIO31 to HIGH */
+  dataVal = XFsbl_In32(GPIO_DATA_1) | GPIO_MIO31_MASK;
+  XFsbl_Out32(GPIO_DATA_1, dataVal);
+  xil_printf("PCIe Reset Complete\r\n");
+
+  // ------------------------------------------------------
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  /* wait after initialization*/
+  (void)usleep(DELAY_5_US);
+  
+  //note: SDK with default FSBL will not generate init_serdes(), when no serdes are available
+#if defined(SERDES_PLL_REF_SEL0_PLLREFSEL0_DEFVAL) || defined(SERDES_PLL_REF_SEL1_PLLREFSEL1_DEFVAL) || defined(SERDES_PLL_REF_SEL2_PLLREFSEL2_DEFVAL)  ||  defined(SERDES_PLL_REF_SEL3_PLLREFSEL3_DEFVAL)
+  //psu_status &=  init_serdes();  --> replace with inner code
+    // code from init_serdes():
+    psu_status &=  psu_resetin_init_data();
+    psu_status &= serdes_fixcal_code();
+    //psu_status &= serdes_enb_coarse_saturation();  --> replace with inner code
+    // code from serdes_enb_coarse_saturation():  
+      /*Enable PLL Coarse Code saturation Logic*/
+      Xil_Out32(0xFD402094, 0x00000010);
+      Xil_Out32(0xFD406094, 0x00000010);
+      Xil_Out32(0xFD40A094, 0x00000010);
+      Xil_Out32(0xFD40E094, 0x00000010);
+    // finished code from serdes_enb_coarse_saturation()
+    psu_status &=  psu_serdes_init_data();
+    psu_status &=  psu_resetout_init_data();
+  // finished code from init_serdes()
+#endif
+  //init_peripheral();  --> replace with inner code
+    // code from init_peripheral():
+    /*SMMU_REG Interrrupt Enable: Followig register need to be written all the time to properly catch SMMU messages.*/
+    //PSU_Mask_Write(0xFD5F0018, 0x8000001FU, 0x8000001FU);  --> replace with inner code
+      // code from serdes_enb_coarse_saturation():  
+      unsigned long RegVal = 0x0;
+
+      RegVal = Xil_In32(0xFD5F0018);
+      RegVal &= ~(0x8000001FU);
+      RegVal |= (0x8000001FU & 0x8000001FU);
+      Xil_Out32(0xFD5F0018, RegVal);
+      // finished code from serdes_enb_coarse_saturation()
+  // finished code from init_peripheral():
+
+  psu_status &=  psu_peripherals_powerdwn_data();
+  psu_status &=    psu_afi_config();
+  psu_ddr_qos_init_data();
+
+// code from psu_init():
+  if (psu_status == 0) {
+    Status= psu_status;
+    // exit on error
+    goto END;
+  }
+  
+  END:
+  
+	return Status;
+ 
+}  
+#else
+u32 TE_XFsbl_XPSU_Default(void)
+{
+  //copy from Xilinx default PSU, xilinx default PSU from Xilinx xfsbl_hooks must be deactivated when TE modified variant is used
+    u32 Status;
+  #ifdef XFSBL_ENABLE_DDR_SR
+    u32 RegVal;
+  #endif
+    
+  #ifdef XFSBL_ENABLE_DDR_SR
+    /* Check if DDR is in self refresh mode */
+    RegVal = Xil_In32(XFSBL_DDR_STATUS_REGISTER_OFFSET) &
+      DDR_STATUS_FLAG_MASK;
+    if (RegVal) {
+      Status = (u32)psu_init_ddr_self_refresh();
+    } else {
+      Status = (u32)psu_init();
+    }
+  #else
+    Status = (u32)psu_init();
+  #endif
+  
+  	return Status;
+}
+#endif
+  
+u32 TE_XFsbl_HookPsuInit_Custom(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+  
+  #ifdef USE_TE_PSU_FOR_SI_INIT
+    Status = TE_XFsbl_TPSU_MODIFIED();
+  #else
+    Status = TE_XFsbl_XPSU_Default();
+  #endif
+
+	return Status;
+}
+  
+
+/*****************************************************************************/
+/**
+  * for xsfbl_board.h
+  *****************************************************************************/
+
+
+/*****************************************************************************/
+/**
+ * This function does board specific initialization.
+ * If there isn't any board specific initialization required, it just returns.
+ *
+ * @param none
+ *
+ * @return
+ * 		- XFSBL_SUCCESS for successful configuration
+ * 		- errors as mentioned in xfsbl_error.h
+ *
+ *****************************************************************************/
+ 
+ 
+u32 TE_XFsbl_BoardInit_Custom(void)
+{
+	u32 Status = XFSBL_SUCCESS;
+  u32 RegVal = 0;
+  u32 temp = 0;
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+  xil_printf("TE0803 TE_XFsbl_BoardInit_Custom\r\n");
+	// /* Add the code here */
+
+  //check USB,PCIe Reset
+  RegVal = XFsbl_In32(GPIO_DATA_1) ;
+  temp = ((RegVal) & (GPIO_MIO30_MASK))>>4;
+  if (temp!=0x1) {
+    xil_printf("USB is hold into reset. (GPIO_DATA_1, Val:%x)\r\n", RegVal);
+  }
+  temp = ((RegVal) & (GPIO_MIO31_MASK))>>5;
+  if (temp!=0x1) {
+    xil_printf("PCIe is hold into reset. (GPIO_DATA_1, Val:%x)\r\n", RegVal);
+  }
+  //check serdes(gtr)
+#if defined(SERDES_PLL_REF_SEL0_PLLREFSEL0_DEFVAL)
+  RegVal = Xil_In32(0xFD4023E4);
+  temp = ((RegVal) & (0x0030))>>4;
+  if(temp!=0x3) {
+    xil_printf("GTR Lane0 LOCK Status failed. (Reg:0xFD4023E4,Val:0x%x)\r\n", RegVal);
+  }
+#endif
+#if defined(SERDES_PLL_REF_SEL1_PLLREFSEL1_DEFVAL)
+  RegVal = Xil_In32(0xFD4063E4);
+  temp = ((RegVal) & (0x0030))>>4;
+  if(temp!=0x3) {
+    xil_printf("GTR Lane1 LOCK Status failed. (Reg:0xFD4063E4,Val:0x%x)\r\n", RegVal);
+  }
+#endif
+#if defined(SERDES_PLL_REF_SEL2_PLLREFSEL2_DEFVAL)
+  RegVal = Xil_In32(0xFD40A3E4);
+  temp = ((RegVal) & (0x0030))>>4;
+  if(temp!=0x3) {
+    xil_printf("GTR Lane2 LOCK Status failed. (Reg:0xFD40A3E4,Val:0x%x)\r\n", RegVal);
+  }
+#endif
+#if defined(SERDES_PLL_REF_SEL3_PLLREFSEL3_DEFVAL)
+  RegVal = Xil_In32(0xFD40E3E4);
+  temp = ((RegVal) & (0x0030))>>4;
+  if(temp!=0x3) {
+    xil_printf("GTR Lane3 LOCK Status failed. (Reg:0xFD40E3E4,Val:0x%x)\r\n", RegVal);
+  }
+#endif
+  
+  #ifdef USE_TE_PSU_FOR_SI_INIT
+
+  #else
+    Status = iic_init();                      // Configure I2C Bus 0 driver instance
+    if (Status != XFSBL_SUCCESS) {
+       xil_printf("Error:I2C Init\r\n");
+       goto END;
+    }
+  #endif
+  
+  // change I2C switch to get access to EEPROM 
+  xil_printf("Configure Carrier I2C Switch 0x73 for EEPROM access\r\n");
+  Status = iic_write8(0x73, 0x00,  0x20);    // Configure I2C Switch
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: Configure Carrier I2C Switch 0x73\r\n");
+     goto END;
+  }
+  
+  xil_printf("\r\n--------------------------------------------------------------------------------\r\n");
+
+  END:
+	return Status;
+}
diff --git a/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h
new file mode 100644
index 0000000000..1565795432
--- /dev/null
+++ b/lib/sw_apps/zynqmp_fsbl/src/te_xfsbl_hooks_te0803.h
@@ -0,0 +1,69 @@
+/******************************************************************************
+*
+* 
+*
+
+******************************************************************************/
+
+/*****************************************************************************/
+/**
+*
+* @file te_xfsbl_hooks_custom.h
+*
+*
+******************************************************************************/
+//rename to correct board name
+#ifndef TE_XFSBL_HOOKS_TE0803_H
+#define TE_XFSBL_HOOKS_TE0803_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/***************************** Include Files *********************************/
+#include "xil_types.h"
+#include "xfsbl_hw.h"
+
+#include "te_iic_platform.h"
+#include "te_si5338.h"
+#include "xparameters.h"
+/************************** Constant Definitions *****************************/
+#define USE_TE_PSU_FOR_SI_INIT //enable TE PSU to write SI on the correct place in the FSBL (Xilinx default PSU is deactivated)
+
+
+#define GPIO_MIO31_MASK	0x00000020U
+#define GPIO_MIO30_MASK	0x00000010U
+#define ICM_CFG_VAL_PCIE	0X1U
+#define DELAY_1_US			0x1U
+#define DELAY_5_US			0x5U
+#define DELAY_32_US			0x20U
+#define DELAY_500_US	  0x500U 
+#define DELAY_1000_US	  0x1000U 
+#define DELAY_AFTER_US	0x2000U 
+/**************************** Type Definitions *******************************/
+
+/***************** Macros (Inline Functions) Definitions *********************/
+
+/************************** Function Prototypes ******************************/
+
+/************************** Variable Definitions *****************************/
+// for xsfbl_hooks.h
+u32 TE_XFsbl_HookBeforeBSDownload_Custom(void );
+
+u32 TE_XFsbl_HookAfterBSDownload_Custom(void );
+
+u32 TE_XFsbl_HookBeforeHandoff_Custom(u32 EarlyHandoff);
+
+u32 TE_XFsbl_HookBeforeFallback_Custom(void);
+
+u32 TE_XFsbl_HookPsuInit_Custom(void);
+
+// for xsfbl_board.h
+u32 TE_XFsbl_BoardInit_Custom(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* XFSBL_HOOKS_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.c
index 8890ef0584..cd9cc154a0 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.c
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
@@ -149,8 +169,14 @@ u32 XFsbl_SpkVer(u64 AcOffset, u32 HashLen)
 	}
 
 	/* Set SPK Signature pointer */
-	Status = (u32)XSecure_RsaInitialize(&SecureRsa, PpkModular,
-		PpkModularEx, PpkExpPtr);
+	if(PpkExpPtr!=NULL) {
+		Status = (u32)XSecure_RsaInitialize(&SecureRsa, PpkModular,
+			PpkModularEx, PpkExpPtr);
+	}
+	else
+	{
+		Status = (u32)(XFSBL_FAILURE);
+	}
 
 	if (Status != XFSBL_SUCCESS) {
 		Status = XFSBL_ERROR_RSA_INITIALIZE;
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.h
index 41911b8f78..fd8fc689a9 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_authentication.h
@@ -1,9 +1,30 @@
 
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
@@ -39,8 +60,8 @@ extern "C" {
 /***************************** Include Files *********************************/
 #include "xfsbl_hw.h"
 #include "xfsbl_main.h"
-#include "xsecure_sha.h"
 #ifdef XFSBL_SECURE
+#include "xsecure_sha.h"
 #include "xsecure_rsa.h"
 #include "xsecure_aes.h"
 #endif
@@ -96,16 +117,17 @@ extern "C" {
 * CSU RSA Register Map
 */
 
-void XFsbl_ShaDigest(const u8 *In, const u32 Size, u8 *Out, u32 HashLen);
+
 #ifdef XFSBL_SECURE
 u32 XFsbl_Authentication(const XFsblPs * FsblInstancePtr, u64 PartitionOffset,
 				u32 PartitionLen, u64 AcOffset,
 				u32 PartitionNum);
+void XFsbl_ShaDigest(const u8 *In, const u32 Size, u8 *Out, u32 HashLen);
 void XFsbl_ShaStart(void * Ctx, u32 HashLen);
 void XFsbl_ShaUpdate(void * Ctx, u8 * Data, u32 Size, u32 HashLen);
 void XFsbl_ShaFinish(void * Ctx, u8 * Hash, u32 HashLen);
 u32 XFsbl_CompareHashs(u8 *Hash1, u8 *Hash2, u32 HashLen);
-u32 XFsbl_Sha3PadSelect(XSecure_Sha3PadType PadType);
+u32 XFsbl_Sha3PadSelect(u8 PadType);
 u32 XFsbl_BhAuthentication(const XFsblPs * FsblInstancePtr, u8 *Data,
 					u64 AcOffset, u8 IsEfuseRsa);
 #endif
@@ -121,7 +143,7 @@ u32 XFsbl_ShaUpdate_DdrLess(const XFsblPs *FsblInstancePtr, void *Ctx,
 extern XCsuDma CsuDma;  /* CSU DMA instance */
 
 #ifdef __cplusplus
-}
+extern "C" }
 #endif
 
 #endif /** XFSBL_AUTHENTICATION_H */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.c
index 3b52900317..2506c8b110 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -21,9 +41,7 @@
 * 1.00  ssc  01/20/16 Initial release
 * 2.0   bv   12/05/16 Made compliance to MISRAC 2012 guidelines
 *                     Added ZCU106 support
-* 3.0	bkm  04/18/18 Added Board specific code w.r.t VADJ
-* 4.0   bsv  11/12/19 Added support for ZCU216 board
-*       bsv  02/05/20 Added support for ZCU208 board
+* 3.0	bkm  18/4/18  Added Board specific code w.r.t VADJ
 *
 * </pre>
 *
@@ -33,8 +51,7 @@
 /***************************** Include Files *********************************/
 #include "xfsbl_board.h"
 #if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106)		\
-		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111) \
-		|| defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
+		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111)
 /************************** Constant Definitions *****************************/
 
 /**************************** Type Definitions *******************************/
@@ -42,19 +59,17 @@
 /***************** Macros (Inline Functions) Definitions *********************/
 
 /************************** Function Prototypes ******************************/
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU216) || \
-	defined(XPS_BOARD_ZCU208)
+#ifdef XPS_BOARD_ZCU104
 static u32 XFsbl_ReadMinMaxEepromVadj(XIicPs* I2c0InstancePtr, u32 *MinVadj, u32 *MaxVadj);
 static u32 XFsbl_CalVadj(u16 MinVoltage, u16 MaxVoltage);
 #endif
 static u32 XFsbl_BoardConfig(void);
-static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr);
+static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr);
 #if defined(XPS_BOARD_ZCU102)
 static void XFsbl_PcieReset(void);
 #endif
 /************************** Variable Definitions *****************************/
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU216) || \
-	defined(XPS_BOARD_ZCU208)
+#ifdef XPS_BOARD_ZCU104
 /*****************************************************************************/
 /**
  * This function is used Read the min and max VADJ values from the FMC EEPROM.
@@ -223,19 +238,13 @@ static u32 XFsbl_CalVadj(u16 MinVoltage, u16 MaxVoltage)
  *	- errors as mentioned in xfsbl_error.h
  *
  *****************************************************************************/
-static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr)
+static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr)
 {
 	u8 WriteBuffer[BUF_LEN] = {0U};
 	s32 Status;
 	u32 UStatus;
 	u32 SlaveAddr;
-#ifndef XPS_BOARD_ZCU216
-#ifndef XPS_BOARD_ZCU208
-	(void) I2c1InstancePtr;
-#endif
-#endif
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111) || \
-	defined(XPS_BOARD_ZCU216)|| defined(XPS_BOARD_ZCU208)
+#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111)
 	XVoutCommands *VoutPtr;
 	u32 VadjSetting = SET_VADJ_0V0;
 	/**
@@ -266,8 +275,7 @@ static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr)
 				VOUT_UV_WARNL_1V8, VOUT_UV_WARNH_1V8, VOUT_UV_FAULTL_1V8,
 				VOUT_UV_FAULTH_1V8}
 	};
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU216)|| \
-	defined(XPS_BOARD_ZCU208)
+#ifdef XPS_BOARD_ZCU104
 	u32 LpcMin;
 	u32 LpcMax;
 #endif
@@ -275,25 +283,14 @@ static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr)
 
 	/* Change the IIC serial clock rate */
 	Status = XIicPs_SetSClk(I2c0InstancePtr, IIC_SCLK_RATE_I2CMUX);
-	if (Status != XST_SUCCESS) {
-		UStatus  = XFSBL_ERROR_I2C_SET_SCLK;
-		XFsbl_Printf(DEBUG_GENERAL, "XFSBL_ERROR_I2C_SET_SCLK\r\n");
-	}
-#if defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
-	Status = XIicPs_SetSClk(I2c1InstancePtr, IIC_SCLK_RATE_I2CMUX);
 	if (Status != XST_SUCCESS) {
 		UStatus  = XFSBL_ERROR_I2C_SET_SCLK;
 		XFsbl_Printf(DEBUG_GENERAL, "XFSBL_ERROR_I2C_SET_SCLK\r\n");
 		goto END;
 	}
-#endif
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU216) || \
-	defined(XPS_BOARD_ZCU208)
-#if defined(XPS_BOARD_ZCU104)
+
+#ifdef XPS_BOARD_ZCU104
 	UStatus = XFsbl_ReadMinMaxEepromVadj(I2c0InstancePtr, &LpcMin, &LpcMax);
-#else
-	UStatus = XFsbl_ReadMinMaxEepromVadj(I2c1InstancePtr, &LpcMin, &LpcMax);
-#endif
 	if(UStatus != XFSBL_SUCCESS)
 	{
 		goto END;
@@ -301,13 +298,13 @@ static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr)
 	VadjSetting = XFsbl_CalVadj(LpcMin, LpcMax);
 #endif
 
-#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU111) || \
-	defined(XPS_BOARD_ZCU106) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208)
+#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU106)
 	/* Set I2C Mux for channel-2 */
 	WriteBuffer[0U] = CMD_CH_2_REG;
 	SlaveAddr = PCA9544A_ADDR;
-#else //ZCU104
+#endif
+
+#ifdef XPS_BOARD_ZCU104
 	/* Set I2C Mux for channel-2 (IRPS5401) */
 	WriteBuffer[0U] = CMD_CH_2_REG_IRPS;
 	SlaveAddr = TCA9548A_ADDR;
@@ -352,8 +349,7 @@ static u32 XFsbl_FMCEnable(XIicPs* I2c0InstancePtr, XIicPs* I2c1InstancePtr)
 #endif
 #endif
 
-#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111) || \
-	defined(XPS_BOARD_ZCU216)|| defined(XPS_BOARD_ZCU208)
+#if defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111)
 	/* PMbus Command for Page Selection */
 	WriteBuffer[0U] = CMD_PAGE_CFG;
 #ifdef XPS_BOARD_ZCU104
@@ -574,18 +570,13 @@ END:
  *****************************************************************************/
 static u32 XFsbl_BoardConfig(void)
 {
-	XIicPs I2c0Instance, I2c1Instance;
+	XIicPs I2c0Instance;
 	XIicPs_Config *I2c0CfgPtr;
 	s32 Status;
 	u32 UStatus;
-#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU216)|| defined(XPS_BOARD_ZCU208)
+#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106)
 	u8 WriteBuffer[BUF_LEN] = {0U};
-#if defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
-	XIicPs_Config *I2c1CfgPtr;
-#endif
 #endif
-
 #if defined(XPS_BOARD_ZCU102)
 	u32 ICMCfgLane[NUM_GT_LANES];
 #endif
@@ -606,25 +597,7 @@ static u32 XFsbl_BoardConfig(void)
 		goto END;
 	}
 
-#if defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
-	/* Initialize the IIC1 driver so that it is ready to use */
-	I2c1CfgPtr = XIicPs_LookupConfig(XPAR_XIICPS_1_DEVICE_ID);
-	if (I2c1CfgPtr == NULL) {
-		UStatus = XFSBL_ERROR_I2C_INIT;
-		XFsbl_Printf(DEBUG_GENERAL, "XFSBL_ERROR_I2C_INIT\r\n");
-		goto END;
-	}
-	Status = XIicPs_CfgInitialize(&I2c1Instance, I2c1CfgPtr,
-			I2c1CfgPtr->BaseAddress);
-	if (Status != XST_SUCCESS) {
-		UStatus = XFSBL_ERROR_I2C_INIT;
-		XFsbl_Printf(DEBUG_GENERAL, "XFSBL_ERROR_I2C_INIT\r\n");
-		goto END;
-	}
-#endif
-
-#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) || \
-	defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
+#if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106)
 	/* Set the IIC serial clock rate */
 	Status = XIicPs_SetSClk(&I2c0Instance, IIC_SCLK_RATE_IOEXP);
 	if (Status != XST_SUCCESS) {
@@ -729,7 +702,7 @@ static u32 XFsbl_BoardConfig(void)
 #endif
 
 
-	Status = XFsbl_FMCEnable(&I2c0Instance, &I2c1Instance);
+	Status = XFsbl_FMCEnable(&I2c0Instance);
 	if (Status != XST_SUCCESS) {
 		XFsbl_Printf(DEBUG_INFO, "FMC VADJ Configuration Not Successful");
 	}
@@ -806,9 +779,12 @@ static void XFsbl_PcieReset(void)
 u32 XFsbl_BoardInit(void)
 {
 	u32 Status;
+  
+/* TE Mod:*/  
+  Status = TE_XFsbl_BoardInit();
+/* TE Mod: finished*/               
 #if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106)		\
-		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111) \
-		|| defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
+		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111)
 	/* Program I2C to configure GT lanes */
 	Status = XFsbl_BoardConfig();
 	if (Status != XFSBL_SUCCESS) {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.h
index e6f6684075..41e4ec8ffd 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_board.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -16,12 +36,11 @@
 *
 * Ver   Who  Date        Changes
 * ----- ---- -------- -------------------------------------------------------
-* 1.00  ssc  01/20/16 Initial release
+* 1.0   ssc  01/20/16 Initial release
 * 2.0   bv   12/05/16 Made compliance to MISRAC 2012 guidelines
 *                     Added ZCU106 support
-* 3.0	bkm  04/18/18 Added Board specific code w.r.t VADJ
-* 4.0   bsv  11/12/19 Added support for ZCU216 board
-*       bsv  02/05/20 Added support for ZCU208 board
+* 3.0	bkm	 18/4/18  Added Board specific code w.r.t VADJ
+*
 *
 * </pre>
 *
@@ -38,9 +57,12 @@ extern "C" {
 
 /***************************** Include Files *********************************/
 #include "xfsbl_hw.h"
+/* TE Mod:*/
+#include "te_xfsbl_hooks.h"
+/* TE Mod: finished*/
+
 #if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106)		\
-		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111) \
-		|| defined(XPS_BOARD_ZCU216) || defined(XPS_BOARD_ZCU208)
+		|| defined(XPS_BOARD_ZCU104) || defined(XPS_BOARD_ZCU111)
 #include "xiicps.h"
 /************************** Constant Definitions *****************************/
 #define GPIO_MIO31_MASK	0x00000020U
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c
index 8442ed57f2..b9387c2968 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c
@@ -1,8 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+ *
+ * Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *
+ *
+ *
  *******************************************************************************/
-
 /*****************************************************************************/
 /**
  *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.h
index 2102863985..f222309f75 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.h
@@ -1,8 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_config.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_config.h
index 7ee817c15f..f7fccd5566 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_config.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_config.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -22,7 +42,6 @@
 *                     Added FSBL_PL_CLEAR_EXCLUDE_VAL, FSBL_USB_EXCLUDE_VAL,
 *                     FSBL_PROT_BYPASS_EXCLUDE_VAL configurations
 * 3.0   vns  03/07/18 Added FSBL_FORCE_ENC_EXCLUDE_VAL configuration
-*
 *</pre>
 *
 * @note
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.c
index 3d30288658..e1a6a5b155 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.c
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
  *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.h
index d15451826e..ae0a452c0c 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_csu_dma.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -47,8 +67,4 @@ extern "C" {
 /************************** Function Prototypes ******************************/
 u32 XFsbl_CsuDmaInit(void);
 
-#ifdef __cplusplus
-}
-#endif
-
 #endif /* XFSBL_CSU_DMA_H*/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.c
index 2fa03bc69b..c9d3748e71 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2019 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+ *
+ * Copyright (C) 2019 Xilinx, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *
+ *
  ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
  *
@@ -26,11 +46,6 @@
  *                     checks
  * 2.0   mn   02/28/19 Add Dynamic DDR initialization support for all DDR DIMMs
  *       mn   03/12/19 Select EEPROM Lower Page for reading SPD data
- *       mn   09/03/19 Fix coverity warnings
- * 3.0   bsv  11/12/19 Added support for ZCU216 board
- *       mn   12/24/19 Enable Address Mirroring based on SPD data
- *       bsv  02/05/20 Added support for ZCU208 board
- *
  * </pre>
  *
  * @note
@@ -182,13 +197,6 @@
 
 #define XFSBL_DDRPHY_BASE_ADDR		0xFD080000U
 
-#define XFSBL_DBI_INFO			XPAR_PSU_DDRC_0_DDR_DATA_MASK_AND_DBI
-
-#define XFSBL_VIDEOBUF			XPAR_PSU_DDRC_0_VIDEO_BUFFER_SIZE
-
-#define XFSBL_BRCMAPPING		XPAR_PSU_DDRC_0_BRC_MAPPING
-
-#define XFSBL_DDR4ADDRMAPPING		XPAR_PSU_DDRC_0_DDR4_ADDR_MAPPING
 /**************************** Type Definitions *******************************/
 
 /***************** Macros (Inline Functions) Definitions *********************/
@@ -431,7 +439,7 @@ u32 XFsbl_ComputeDdr4Params(u8 *SpdData, struct DdrcInitData *DdrDataPtr)
 		case DDR4_SPD_MODULETYPE_72B_SO_UDIMM:
 			PDimmPtr->UDimm = 1U;
 			if (Ddr4SpdData->ModSection.unbuffered.AddrMapping & 0x1U)
-				PDimmPtr->AddrMirror = 1U;
+				PDimmPtr->AddrMirror = XPAR_PSU_DDRC_0_DDR_ADDRESS_MIRRORING;
 			break;
 
 		default:
@@ -558,7 +566,7 @@ u32 XFsbl_ComputeDdr3Params(u8 *SpdData, struct DdrcInitData *DdrDataPtr)
 		case DDR3_SPD_MODULETYPE_16B_SO_DIMM:
 		case DDR3_SPD_MODULETYPE_32B_SO_DIMM:
 			if (Ddr3SpdData->ModSection.unbuffered.AddrMapping & 0x1U)
-				PDimmPtr->AddrMirror = 1U;
+				PDimmPtr->AddrMirror = XPAR_PSU_DDRC_0_DDR_ADDRESS_MIRRORING;
 			break;
 
 		default:
@@ -653,7 +661,7 @@ u32 XFsbl_ComputeLpDdrParams(u8 *SpdData, struct DdrcInitData *DdrDataPtr)
 		PDimmPtr->EccBusWidth = 8U;
 	else
 		PDimmPtr->EccBusWidth = 0U;
-	PDimmPtr->DramWidth = 1U << ((LpDdrSpdData->Organization & 0x7U) + 2U);
+	PDimmPtr->DramWidth = LpDdrSpdData->Organization & 0x7U;
 
 	PDimmPtr->AddrMirror = 0U;
 	PDimmPtr->RDimm = 0U;
@@ -716,8 +724,7 @@ u32 XFsbl_ComputeLpDdrParams(u8 *SpdData, struct DdrcInitData *DdrDataPtr)
 }
 
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208))
+		|| defined(XPS_BOARD_ZCU111))
 /*****************************************************************************/
 /**
  * This function computes DIMM parameters based upon the SPD information.
@@ -800,7 +807,6 @@ static void XFsbl_DdrCalcDdr4HifAddr(struct DdrcInitData *DdrDataPtr, u32 *HifAd
 	}
 }
 
-#if (XFSBL_VIDEOBUF != 0U)
 /*****************************************************************************/
 /**
  * This function calculates the HIF Addresses for Video mapping mode
@@ -912,9 +918,7 @@ static void XFsbl_DdrCalcHifAddrVideo(struct DdrcInitData *DdrDataPtr,
 		}
 	}
 }
-#endif
 
-#if (XFSBL_BRCMAPPING == 1U)
 /*****************************************************************************/
 /**
  * This function calculates the HIF Addresses for Bank-Row-Column mapping mode
@@ -963,9 +967,7 @@ static void XFsbl_DdrCalcHifAddrBrcMap(struct DdrcInitData *DdrDataPtr,
 		Position++;
 	}
 }
-#endif
 
-#if (XFSBL_DDR4ADDRMAPPING == 1U)
 /*****************************************************************************/
 /**
  * This function calculates the HIF Addresses for Address Mapping Enabled mode
@@ -1013,7 +1015,6 @@ static void XFsbl_DdrCalcHifAddrMemMap(struct DdrcInitData *DdrDataPtr, u32 *Hif
 		Position++;
 	}
 }
-#endif
 
 /*****************************************************************************/
 /**
@@ -1075,7 +1076,7 @@ static void XFsbl_DdrCalcBankAddr(struct DdrcInitData *DdrDataPtr, u32 *HifAddr)
 	/* Calculate Bank Addresses */
 	for (BankBit = 0U; BankBit < XFSBL_MAX_BANKS; BankBit++) {
 		if (BankBit < PDimmPtr->NumBankAddr) {
-			Index = BankBit + 2U;
+			Index = 0U;
 
 			while (HifAddr[Index] != XFSBL_HIF_BANK(BankBit)) {
 				Index++;
@@ -1108,7 +1109,7 @@ static void XFsbl_DdrCalcBgAddr(struct DdrcInitData *DdrDataPtr, u32 *HifAddr)
 	/* Calculate Bank Group Addresses */
 	for (BgBit = 0U; BgBit < XFSBL_MAX_BANK_GROUPS; BgBit++) {
 		if (BgBit < PDimmPtr->NumBgAddr) {
-			Index = BgBit + 2U;
+			Index = 0U;
 
 			while (HifAddr[Index] != XFSBL_HIF_BG(BgBit)) {
 				Index++;
@@ -1145,7 +1146,7 @@ static void XFsbl_DdrCalcColAddr(struct DdrcInitData *DdrDataPtr, u32 *HifAddr)
 	/* Calculate Column Addresses */
 	for (ColBit = 2U; ColBit < XFSBL_MAX_COLUMNS; ColBit++) {
 		if (ColBit < PDimmPtr->NumColAddr) {
-			Index = ColBit;
+			Index = 0U;
 
 			while (HifAddr[Index] != XFSBL_HIF_COLUMN(ColBit)) {
 				Index++;
@@ -1180,7 +1181,7 @@ static void XFsbl_DdrCalcRowAddr(struct DdrcInitData *DdrDataPtr, u32 *HifAddr)
 	/* Calculate Row Addresses */
 	for (RowBit = 0U; RowBit < XFSBL_MAX_ROWS; RowBit++) {
 		if (RowBit < PDimmPtr->NumRowAddr) {
-			Index = RowBit + 6U;
+			Index = 0U;
 
 			while (HifAddr[Index] != XFSBL_HIF_ROW(RowBit)) {
 				Index++;
@@ -1207,47 +1208,50 @@ static void XFsbl_DdrCalcAddrMap(struct DdrcInitData *DdrDataPtr)
 {
 	XFsbl_DimmParams *PDimmPtr = &DdrDataPtr->PDimm;
 	u32 HifAddr[40U] = {0U};
+	u32 VideoBuf = XPAR_PSU_DDRC_0_VIDEO_BUFFER_SIZE;
+	u32 BrcMapping = XPAR_PSU_DDRC_0_BRC_MAPPING;
+	u32 Ddr4AddrMapping = XPAR_PSU_DDRC_0_DDR4_ADDR_MAPPING;
 	u32 RegVal[12U];
 	u32 Index;
 
-#if (XFSBL_VIDEOBUF != 0U)
-	/* Calculate the HIF Addresses when Video Buffers are Enabled */
-	XFsbl_DdrCalcHifAddrVideo(DdrDataPtr, HifAddr, VideoBuf);
-#elif (XFSBL_BRCMAPPING == 1U)
-	if (PDimmPtr->MemType != SPD_MEMTYPE_DDR4) {
-		/*
-		 * Calculate the HIF Addresses for Non-DDR4 Mapping
-		 */
-		XFsbl_DdrCalcHifAddr(DdrDataPtr, HifAddr);
+	if (VideoBuf != 0U) {
+		/* Calculate the HIF Addresses when Video Buffers are Enabled */
+		XFsbl_DdrCalcHifAddrVideo(DdrDataPtr, HifAddr, VideoBuf);
+	} else if (BrcMapping == 1U) {
+		if (PDimmPtr->MemType != SPD_MEMTYPE_DDR4) {
+			/*
+			 * Calculate the HIF Addresses for Non-DDR4 Mapping
+			 */
+			XFsbl_DdrCalcHifAddr(DdrDataPtr, HifAddr);
+		} else {
+			/*
+			 * Calculate the HIF Addresses when Bank-Row-Column Mapping is
+			 * Enabled
+			 */
+			XFsbl_DdrCalcHifAddrBrcMap(DdrDataPtr, HifAddr);
+		}
 	} else {
-		/*
-		 * Calculate the HIF Addresses when Bank-Row-Column Mapping is
-		 * Enabled
-		 */
-		XFsbl_DdrCalcHifAddrBrcMap(DdrDataPtr, HifAddr);
-	}
-#else
-	if (PDimmPtr->MemType != SPD_MEMTYPE_DDR4) {
-		/*
-		 * Calculate the HIF Addresses for Non-DDR4 Mapping
-		 */
-		XFsbl_DdrCalcHifAddr(DdrDataPtr, HifAddr);
+		if (PDimmPtr->MemType != SPD_MEMTYPE_DDR4) {
+			/*
+			 * Calculate the HIF Addresses for Non-DDR4 Mapping
+			 */
+			XFsbl_DdrCalcHifAddr(DdrDataPtr, HifAddr);
 
-	} else {
-#if (XFSBL_DDR4ADDRMAPPING == 1U)
-		/*
-		 * Calculate the HIF Addresses when DDR4 Address Mapping
-		 * is Enabled
-		 */
-		XFsbl_DdrCalcHifAddrMemMap(DdrDataPtr, HifAddr);
-#else
-		/*
-		 * Calculate the HIF Addresses for default DDR4 Mapping
-		 */
-		XFsbl_DdrCalcDdr4HifAddr(DdrDataPtr, HifAddr);
-#endif
+		} else {
+			if (Ddr4AddrMapping == 1U) {
+				/*
+				 * Calculate the HIF Addresses when DDR4 Address Mapping
+				 * is Enabled
+				 */
+				XFsbl_DdrCalcHifAddrMemMap(DdrDataPtr, HifAddr);
+			} else {
+				/*
+				 * Calculate the HIF Addresses for default DDR4 Mapping
+				 */
+				XFsbl_DdrCalcDdr4HifAddr(DdrDataPtr, HifAddr);
+			}
+		}
 	}
-#endif
 
     if (PDimmPtr->BusWidth <= 32U) {
 	for (Index = 0U; Index < 39U; Index++) {
@@ -1391,7 +1395,7 @@ static u32 XFsbl_DdrcCalcCommonRegVal(struct DdrcInitData *DdrDataPtr,
 		XFsbl_DimmParams *PDimmPtr, u32 *DdrCfg)
 {
 
-	DdrCfg[DDR_DEVICE_CONFIG] = (PDimmPtr->DramWidth >= 4U) ? XFsbl_GetLog2(PDimmPtr->DramWidth) - 2U : 0U;
+	DdrCfg[DDR_DEVICE_CONFIG] = XFsbl_GetLog2(PDimmPtr->DramWidth) - 2U;
 
 	DdrCfg[DDR_ACTIVE_RANKS] = (PDimmPtr->NumRankAddr * 2U) + 1U;
 
@@ -1893,8 +1897,7 @@ static u32 XFsbl_DdrcCalcDdr4RegVal(XFsbl_DimmParams *PDimmPtr, u32 *DdrCfg)
 }
 
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208))
+		|| defined(XPS_BOARD_ZCU111))
 /*****************************************************************************/
 /**
  * This function calculates the DDRC register values for DDR3
@@ -2965,8 +2968,7 @@ static void XFsbl_DdrcRegsWrite(XFsbl_DimmParams *PDimmPtr, u32 *DdrCfg)
 }
 
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208))
+		|| defined(XPS_BOARD_ZCU111))
 /*****************************************************************************/
 /**
  * This function calculates and writes DDR controller registers
@@ -3261,7 +3263,7 @@ static u32 XFsbl_PhyCalcDdr4RegVal(XFsbl_DimmParams *PDimmPtr, u32 *PhyCfg)
 	if (PDimmPtr->AddrMirror && PDimmPtr->RDimm)
 		PhyCfg[PHY_RC13] = 0x8U;
 
-	PhyCfg[PHY_RC10] = (PDimmPtr->SpeedBin > 1600U) ? ((PDimmPtr->SpeedBin - 1600U) / 266U) : 0U;
+	PhyCfg[PHY_RC10] = XFSBL_MAX(0U, (PDimmPtr->SpeedBin - 1600U) / 266U);
 
 	if (PDimmPtr->Parity && PDimmPtr->RDimm)
 		PhyCfg[PHY_RC8] = 0x8U;
@@ -3436,8 +3438,7 @@ static u32 XFsbl_PhyCalcDdr4RegVal(XFsbl_DimmParams *PDimmPtr, u32 *PhyCfg)
 }
 
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208))
+		|| defined(XPS_BOARD_ZCU111))
 /*****************************************************************************/
 /**
  * This function calculates the PHY register values for DDR3
@@ -5196,8 +5197,7 @@ static void XFsbl_PhyRegsWrite(XFsbl_DimmParams *PDimmPtr, u32 *PhyCfg)
 }
 
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208))
+		|| defined(XPS_BOARD_ZCU111))
 /*****************************************************************************/
 /**
  * This function calculates and writes the DDR-PHY registers
@@ -5510,7 +5510,7 @@ static void XFsbl_RdbiWrkAround(XFsbl_DimmParams *PDimmPtr)
 
 	for (Index = 0U; Index < (PDimmPtr->Ecc ? 9U : 8U); Index++) {
 		CalByte[Index] = 0U;
-		for (Index1 = 0U; Index1 < 8U; Index1++) {
+		for (Index1 = 0U; Index1 < 8U; Index++) {
 			CalByte[Index] = CalByte[Index] + DqRbd[Index][Index1];
 		}
 		CalByte[Index] = CalByte[Index] / 8U;
@@ -6313,22 +6313,24 @@ END:
 static void XFsbl_InitilizeDdrParams(struct DdrcInitData *DdrDataPtr)
 {
 	XFsbl_DimmParams *PDimmPtr = &DdrDataPtr->PDimm;
-
-	PDimmPtr->DataMask = (XFSBL_DBI_INFO & 0x4U) >> 2U;
-
-#if (XFSBL_DBI_INFO == 1U) || (XFSBL_DBI_INFO == 4U)
-	PDimmPtr->RdDbi = 1U;
-	PDimmPtr->WrDbi = 1U;
-#elif (XFSBL_DBI_INFO == 2U) || (XFSBL_DBI_INFO == 5U)
-	PDimmPtr->RdDbi = 1U;
-	PDimmPtr->WrDbi = 0U;
-#elif (XFSBL_DBI_INFO == 3U) || (XFSBL_DBI_INFO == 6U)
-	PDimmPtr->RdDbi = 0U;
-	PDimmPtr->WrDbi = 1U;
-#else
-	PDimmPtr->RdDbi = 0U;
-	PDimmPtr->WrDbi = 0U;
-#endif
+	u32 DbiInfo;
+
+	DbiInfo = XPAR_PSU_DDRC_0_DDR_DATA_MASK_AND_DBI;
+	PDimmPtr->DataMask = (DbiInfo & 0x4U) >> 2U;
+
+	if ((DbiInfo == 1U) || (DbiInfo == 4U)) {
+		PDimmPtr->RdDbi = 1U;
+		PDimmPtr->WrDbi = 1U;
+	} else if ((DbiInfo == 2U) || (DbiInfo == 5U)) {
+		PDimmPtr->RdDbi = 1U;
+		PDimmPtr->WrDbi = 0U;
+	} else if ((DbiInfo == 3U) || (DbiInfo == 6U)) {
+		PDimmPtr->RdDbi = 0U;
+		PDimmPtr->WrDbi = 1U;
+	} else {
+		PDimmPtr->RdDbi = 0U;
+		PDimmPtr->WrDbi = 0U;
+	}
 
 	PDimmPtr->Ecc = XPAR_PSU_DDRC_0_HAS_ECC;
 	PDimmPtr->En2ndClk = XPAR_PSU_DDRC_0_DDR_2ND_CLOCK;
@@ -6520,8 +6522,7 @@ static void XFsbl_InitilizeDdrParams(struct DdrcInitData *DdrDataPtr)
 }
 
 #if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208)
+		|| defined(XPS_BOARD_ZCU111)
 /*****************************************************************************/
 /**
  * This function calculates and writes DDR controller registers
@@ -6835,8 +6836,7 @@ u32 XFsbl_DdrInit(void)
 	u32 Status;
 	u8 SpdData[512U];
 #if !(defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208)) || defined(XFSBL_ENABLE_DDR_SR)
+	|| defined(XPS_BOARD_ZCU111)) || defined(XFSBL_ENABLE_DDR_SR)
 	u32 RegVal;
 #endif
 
@@ -6854,10 +6854,9 @@ u32 XFsbl_DdrInit(void)
 	}
 
 #if defined(XPS_BOARD_ZCU102) || defined(XPS_BOARD_ZCU106) \
-	|| defined(XPS_BOARD_ZCU111) || defined(XPS_BOARD_ZCU216) \
-	|| defined(XPS_BOARD_ZCU208)
-	/* ZCU102, ZCU106 and ZCU111, ZCU216 and ZCU208 Boards have support
-	 * only for DDR4 DIMMs. Skip checking for DDR type for these boards.
+		|| defined(XPS_BOARD_ZCU111)
+	/* ZCU102, ZCU106 and ZCU111 Boards have support only for DDR4
+	 * DIMMs. Skip checking for DDR type for these boards.
 	 */
 	Status = XFsbl_Ddr4Init(SpdData, &DdrData);
 	if (XFSBL_SUCCESS != Status) {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.h
index 22f0206fe4..9bde801de3 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_ddr_init.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2019 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+ *
+ * Copyright (C) 2019 Xilinx, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *
+ *
  ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
  *
@@ -18,14 +38,8 @@
  * Ver   Who  Date        Changes
  * ----- ---- -------- -------------------------------------------------------
  * 1.0   mn   07/06/18 Add DDR initialization support for new DDR DIMM part
- *       mn   07/18/18 Move iicps.h inclusion under ZCU102 and ZCU106 macro
- *                     checks
+ *       mn   07/30/18 Define some DDR registers addresses if not defined
  * 2.0   mn   02/28/19 Add Dynamic DDR initialization support for all DDR DIMMs
- *       mn   03/12/19 Select EEPROM Lower Page for reading SPD data
- *       mn   09/03/19 Fix coverity warnings
- * 3.0   bsv  11/12/19 Added support for ZCU216 board
- *       mn   12/24/19 Enable Address Mirroring based on SPD data
- *       bsv  02/05/20 Added support for ZCU208 board
  *
  * </pre>
  *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_debug.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_debug.h
index 92c86e9908..d3d1261444 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_debug.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_debug.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *****************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.c
index 8e80c5083b..76ae52f11c 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.c
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+ *
+ * Copyright (C) 2017 Xilinx, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ *
+ *
+ *
  *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
@@ -17,7 +37,6 @@
 * Ver   Who  Date     Changes
 * ----- ---- -------- -------------------------------------------------------
 * 1.0   bvikram  02/01/17 First release
-* 2.0   bvikram  09/30/20 Fix USB boot mode
 *
 * </pre>
 *
@@ -37,32 +56,17 @@
 #define USB_MODES_NUM				2U
 #define STRING_DESCRIPTORS_NUM		6U
 
+static void XFsbl_DfuSetState(u32 DfuState );
+
 /**************************** Type Definitions *******************************/
+extern struct XUsbPsu UsbInstance;
 struct XFsblPs_DfuIf DfuObj;
 extern u32 DownloadDone;
 extern u8* DfuVirtFlash;
-extern struct Usb_DevData UsbInstance;
-
-/* Initialize a DFU data structure */
-XFsbl_UsbCh9_Data Dfu_data = {
-        .Ch9_func = {
-                .XFsblPs_Ch9SetupDevDescReply = XFsbl_Ch9SetupDevDescReply,
-                .XFsblPs_Ch9SetupCfgDescReply = XFsbl_Ch9SetupCfgDescReply,
-                .XFsblPs_Ch9SetupBosDescReply = XFsbl_Ch9SetupBosDescReply,
-                .XFsblPs_Ch9SetupStrDescReply = XFsbl_Ch9SetupStrDescReply,
-                .XFsblPs_SetConfiguration = XFsbl_SetConfiguration,
-                /* Hook the set interface handler */
-                .XFsblPs_SetInterfaceHandler = XFsbl_DfuSetIntf,
-                /* Hook up storage class handler */
-                .XFsblPs_ClassReq = XFsbl_DfuClassReq,
-                /* Set the DFU address for call back */
-        },
-        .Data_ptr = (void *)&DfuObj,
-};
 
 /* Device Descriptors */
-static XFsblPs_UsbStdDevDesc __attribute__ ((aligned(16))) DDesc = {
-	/* USB 2.0 */
+static XFsblPs_UsbStdDevDesc __attribute__ ((aligned(16))) DDesc[] = {
+	{/* USB 2.0 */
 		(u8)sizeof(XFsblPs_UsbStdDevDesc), /* bLength */
 		USB_DEVICE_DESC, /* bDescriptorType */
 		(0x0200U), /* bcdUSB 2.0 */
@@ -77,17 +81,118 @@ static XFsblPs_UsbStdDevDesc __attribute__ ((aligned(16))) DDesc = {
 		0x02U, /* iProduct */
 		0x03U, /* iSerialNumber */
 		0x01U /* bNumConfigurations */
-	};
+	},
+	{/* USB 3.0 */
+		(u8)sizeof(XFsblPs_UsbStdDevDesc), /* bLength */
+		USB_DEVICE_DESC, /* bDescriptorType */
+		(0x0300U), /* bcdUSB 3.0 */
+		0x00U, /* bDeviceClass */
+		0x00U, /* bDeviceSubClass */
+		0x00U, /* bDeviceProtocol */
+		0x09U, /* bMaxPackedSize0 */
+		(0x03FDU), /* idVendor */
+		(0x0050U), /* idProduct */
+		(0x0404U), /* bcdDevice */
+		0x01U, /* iManufacturer */
+		0x02U, /* iProduct */
+		0x03U, /* iSerialNumber */
+		0x01U /* bNumConfigurations */
+	}};
 
 /* String Descriptors */
-static char* StringList[STRING_DESCRIPTORS_NUM] = {
+static char* StringList[USB_MODES_NUM][STRING_DESCRIPTORS_NUM] = {
+	{
 		"UNUSED",
 		"XILINX INC",
 		"DFU 2.0 emulation v 1.1",
 		"2A49876D9CC1AA4",
 		"Xilinx DFU Downloader",
 		"7ABC7ABC7ABC7ABC7ABC7ABC"
-	};
+	},
+	{
+		"UNUSED",
+		"XILINX INC",
+		"DFU 3.0 emulation v 1.1",
+		"2A49876D9CC1AA4",
+		"Xilinx DFU Downloader",
+		"7ABC7ABC7ABC7ABC7ABC7ABC"
+	},
+};
+
+static XFsblPs_Usb30Config __attribute__ ((aligned(16))) Config3 = {
+	/* Std Config */
+	{	(u8)sizeof(XFsblPs_UsbStdCfgDesc), /* bLength */
+		USB_CONFIG_DESC, /* bDescriptorType */
+		(u16) sizeof(XFsblPs_Usb30Config), /* wTotalLength */
+		0x01U, /* bNumInterfaces */
+		0x01U, /* bConfigurationValue */
+		0x00U, /* iConfiguration */
+		0xC0U, /* bmAttribute */
+		0x00U}, /* bMaxPower  */
+
+	/* Interface Config */
+	{	(u8)sizeof(XFsblPs_UsbStdIfDesc), /* bLength */
+		USB_INTERFACE_CFG_DESC, /* bDescriptorType */
+		0x00U, /* bInterfaceNumber */
+		0x00U, /* bAlternateSetting */
+		0x02U, /* bNumEndPoints */
+		0xFFU, /* bInterfaceClass */
+		0xFFU, /* bInterfaceSubClass */
+		0xFFU, /* bInterfaceProtocol */
+		0x04U}, /* iInterface */
+
+	/* Bulk In Endpoint Config */
+	{	(u8)sizeof(XFsblPs_UsbStdEpDesc), /* bLength */
+		USB_ENDPOINT_CFG_DESC, /* bDescriptorType */
+		0x81U, /* bEndpointAddress */
+		0x02U, /* bmAttribute  */
+		0x00U, /* wMaxPacketSize - LSB */
+		0x04U, /* wMaxPacketSize - MSB */
+		0x00U}, /* bInterval */
+
+	/* SS Endpoint companion  */
+	{	(u8)sizeof(XFsblPs_UsbStdEpSsCompDesc), /* bLength */
+		0x30U, /* bDescriptorType */
+		0x0FU, /* bMaxBurst */
+		0x00U, /* bmAttributes */
+		0x00U}, /* wBytesPerInterval */
+
+	/* Bulk Out Endpoint Config */
+	{	(u8)sizeof(XFsblPs_UsbStdEpDesc), /* bLength */
+		USB_ENDPOINT_CFG_DESC, /* bDescriptorType */
+		0x01U, /* bEndpointAddress */
+		0x02U, /* bmAttribute  */
+		0x00U, /* wMaxPacketSize - LSB */
+		0x04U, /* wMaxPacketSize - MSB */
+		0x00U}, /* bInterval */
+
+	/* SS Endpoint companion  */
+	{	(u8)sizeof(XFsblPs_UsbStdEpSsCompDesc), /* bLength */
+		0x30U, /* bDescriptorType */
+		0x0FU, /* bMaxBurst */
+		0x00U, /* bmAttributes */
+		0x00U}, /* wBytesPerInterval */
+
+	/*** DFU Interface descriptor ***/
+	{	(u8)sizeof(XFsblPs_UsbStdIfDesc), /* bLength */
+		USB_INTERFACE_CFG_DESC, /* bDescriptorType */
+		0x00U, /* bInterfaceNumber */
+		0x01U, /* bAlternateSetting */
+		0x00U, /* bNumEndPoints */
+		0xFEU, /* bInterfaceClass DFU application specific class code */
+		0x01U, /* bInterfaceSubClass DFU device firmware upgrade code*/
+		0x02U, /* bInterfaceProtocol DFU mode protocol*/
+		0x04U}, /* iInterface DFU string descriptor*/
+
+	/**** DFU functional descriptor ****/
+	{	(u8)sizeof(XFsblPs_UsbDfuFuncDesc), /* bLength*/
+		DFUFUNC_DESCR, /* bDescriptorType DFU functional descriptor type */
+		0x3U, /* bmAttributes Device is only download/upload capable */
+		8192U, /* wDetatchTimeOut 8192 ms */
+		DFU_MAX_TRANSFER, /*wTransferSize DFU block size 1024*/
+		0x0110U /*bcdDfuVersion 1.1 */
+	}
+};
 
 static XFsblPs_UsbConfig __attribute__ ((aligned(16))) Config2 = {
 	/* Std Config */
@@ -206,12 +311,22 @@ u32 XFsbl_Ch9SetupStrDescReply(u8 *BufPtr, u32 BufferLen, u8 Index)
 		goto END;
 	}
 
-	String = StringList[Index];
+	SStatus = XUsbPsu_IsSuperSpeed(&UsbInstance);
+	if(SStatus != XST_SUCCESS) {
+		/* USB 2.0 */
+		String = StringList[0][Index];
+
+	} else {
+		/* USB 3.0 */
+		String = StringList[1][Index];
+	}
+
 	StringLen = strlen(String);
 
 	/* Index 0 is LangId which is special as we can not represent
 	 * the string required in the table above.Therefore we handle
-	 * index 0 as a special case. */
+	 * index 0 as a special case.*/
+
 	if (0U == Index) {
 		StringDesc.Length = 4U;
 		StringDesc.DescriptorType = 0x03U;
@@ -277,7 +392,15 @@ u32 XFsbl_Ch9SetupDevDescReply(u8 *BufPtr, u32 BufferLen)
 		goto END;
 	}
 
-	(void)memcpy(BufPtr, &DDesc, DevDescLength);
+	SStatus = XUsbPsu_IsSuperSpeed(&UsbInstance);
+	if(SStatus != XST_SUCCESS) {
+		/* USB 2.0 */
+		(void)memcpy(BufPtr, &DDesc[0], DevDescLength);
+
+	} else {
+		/* USB 3.0 */
+		(void)memcpy(BufPtr, &DDesc[1], DevDescLength);
+	}
 
 END:
 	return DevDescLength;
@@ -308,8 +431,17 @@ u32 XFsbl_Ch9SetupCfgDescReply(u8 *BufPtr, u32 BufferLen)
 		goto END;
 	}
 
-	Config = (u8 *)&Config2;
-	CfgDescLen = sizeof(XFsblPs_UsbConfig);
+	SStatus = XUsbPsu_IsSuperSpeed(&UsbInstance);
+	if(SStatus != XST_SUCCESS) {
+		/* USB 2.0 */
+		Config = (u8 *)&Config2;
+		CfgDescLen = sizeof(XFsblPs_UsbConfig);
+	} else {
+		/* USB 3.0 */
+		Config = (u8 *)&Config3;
+		CfgDescLen = sizeof(XFsblPs_Usb30Config);
+	}
+
 	if (BufferLen < CfgDescLen) {
 		CfgDescLen = 0U;
 		goto END;
@@ -381,26 +513,24 @@ END:
 
 /****************************************************************************/
 /**
- * @brief	This function changes State of Core to USB configured State.
+ * Changes State of Core to USB configured State.
  *
- * @param	InstancePtr is a pointer to XUsbPsu instance of the controller
- * @param	Ctrl is a pointer to the Setup packet data
+ * @param	Ctrl is a pointer to the Setup packet data.
  *
- * @return	XST_SUCCESS on success and error code on failure
+ * @return	XST_SUCCESS else XST_FAILURE
  *
  * @note		None.
  *
  *****************************************************************************/
-s32 XFsbl_SetConfiguration(struct Usb_DevData* InstancePtr, SetupPacket *Ctrl)
+s32 XFsbl_SetConfiguration(SetupPacket *Ctrl)
 {
 	s32 Ret;
 
-	Xil_AssertNonvoid(InstancePtr != NULL);
 	Xil_AssertNonvoid(Ctrl != NULL);
 
-	((struct XUsbPsu*)(InstancePtr->PrivateData))->IsConfigDone = 0U;
+	UsbInstance.IsConfigDone = 0U;
 
-	switch (InstancePtr->State) {
+	switch (UsbInstance.AppData->State) {
 		case XUSBPSU_STATE_DEFAULT:
 		{
 			Ret = XST_FAILURE;
@@ -409,7 +539,7 @@ s32 XFsbl_SetConfiguration(struct Usb_DevData* InstancePtr, SetupPacket *Ctrl)
 
 		case XUSBPSU_STATE_ADDRESS:
 		{
-			InstancePtr->State = XUSBPSU_STATE_CONFIGURED;
+			UsbInstance.AppData->State = XUSBPSU_STATE_CONFIGURED;
 			Ret = XST_SUCCESS;
 		}
 			break;
@@ -433,8 +563,7 @@ s32 XFsbl_SetConfiguration(struct Usb_DevData* InstancePtr, SetupPacket *Ctrl)
 /*****************************************************************************
  * This function handles setting of DFU state.
  *
- * @param	InstancePtr is a pointer to XUsbPsu instance of the controller
- * @param	DfuState is a value of the DFU state to be set
+ * @param	dfu_state is a value of the DFU state to be set
  *
  * @return
  *				None.
@@ -442,8 +571,7 @@ s32 XFsbl_SetConfiguration(struct Usb_DevData* InstancePtr, SetupPacket *Ctrl)
  * @note		None.
  *
  ******************************************************************************/
-void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState) {
-	int Status = XST_FAILURE;
+static void XFsbl_DfuSetState(u32 DfuState) {
 
 	switch (DfuState) {
 
@@ -452,13 +580,9 @@ void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState) {
 			DfuObj.CurrState = STATE_APP_IDLE;
 			DfuObj.NextState = STATE_APP_DETACH;
 			DfuObj.CurrStatus = DFU_STATUS_OK;
-			/* Set to runtime mode by default */
-			DfuObj.IsDfu = (u8)FALSE;
-			DfuObj.RuntimeToDfu = (u8)FALSE;
-			++DownloadDone;
-			Status = XST_SUCCESS;
+			DfuObj.RuntimeToDfu = 0U;
 		}
-			break;
+		break;
 
 		case STATE_APP_DETACH:
 		{
@@ -469,17 +593,11 @@ void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState) {
 
 				/* Wait For USB Reset to happen */
 				XFsbl_DfuWaitForReset();
-				/* Setting Dfu Mode */
-				DfuObj.IsDfu = (u8)TRUE;
-				/*
-				 * Set this flag to indicate we are going
-				 * from runtime to dfu mode
-				 */
-				DfuObj.RuntimeToDfu = (u8)TRUE;
-				DfuObj.CurrState = STATE_DFU_IDLE;
-				DfuObj.NextState = STATE_DFU_DOWNLOAD_SYNC;
-				DfuObj.IsDfu = (u8)TRUE;
-				Status = XST_SUCCESS;
+
+				/* Set this flag to indicate we are going from runtime to dfu mode */
+				DfuObj.RuntimeToDfu = 1U;
+
+				/* fall through */
 			} else if (DfuObj.CurrState == STATE_DFU_IDLE) {
 				/* Wait For USB Reset to happen */
 				XFsbl_DfuWaitForReset();
@@ -487,26 +605,21 @@ void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState) {
 				DfuObj.CurrState = STATE_APP_IDLE;
 				DfuObj.NextState = STATE_APP_DETACH;
 				DfuObj.CurrStatus = DFU_STATUS_OK;
-				DfuObj.IsDfu = (u8)FALSE;
-				Status = XST_SUCCESS;
-			}
-			else {
-				/* Error */
+				break;
+			} else {
+				goto stall;
 			}
 		}
-			break;
+
 		case STATE_DFU_IDLE:
 		{
 			DfuObj.CurrState = STATE_DFU_IDLE;
 			DfuObj.NextState = STATE_DFU_DOWNLOAD_SYNC;
-			DfuObj.IsDfu = (u8)TRUE;
-			Status = XST_SUCCESS;
 		}
 		break;
 		case STATE_DFU_DOWNLOAD_SYNC:
 		{
 			DfuObj.CurrState = STATE_DFU_DOWNLOAD_SYNC;
-			Status = XST_SUCCESS;
 		}
 		break;
 
@@ -514,14 +627,13 @@ void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState) {
 		case STATE_DFU_DOWNLOAD_IDLE:
 		case STATE_DFU_ERROR:
 		default:
-			break;
-	}
+		{
+		stall:
+			 /* Unsupported command. Stall the end point.*/
 
-	if (Status != XST_SUCCESS) {
-		/* Unsupported command. Stall the end point. */
-		DfuObj.CurrState = STATE_DFU_ERROR;
-		XUsbPsu_Ep0StallRestart(
-			(struct XUsbPsu*)InstancePtr->PrivateData);
+			DfuObj.CurrState = STATE_DFU_ERROR;
+			XUsbPsu_EpSetStall(&UsbInstance, 0U, XUSBPSU_EP_DIR_IN);
+		}
 	}
 
 }
@@ -556,32 +668,27 @@ void XFsbl_DfuReset(struct Usb_DevData* InstancePtr)
  * @note		None.
  *
  ******************************************************************************/
-void XFsbl_DfuSetIntf(struct Usb_DevData* InstancePtr, SetupPacket *SetupData)
+void XFsbl_DfuSetIntf(SetupPacket *SetupData)
 {
 	/* Setting the alternate setting requested */
 	DfuObj.CurrentInf = SetupData->wValue;
-	if (DfuObj.RuntimeToDfu == (u8)TRUE) {
-		/*
-		 * Clear the flag, before entering into DFU
-		 * mode from runtime mode.
-		 */
-		DfuObj.RuntimeToDfu = (u8)FALSE;
-		/* Entering DFU_IDLE state */
-		XFsbl_DfuSetState(InstancePtr, STATE_DFU_IDLE);
-	}
-	else if (DfuObj.CurrentInf >= DFU_ALT_SETTING) {
+	if ((DfuObj.CurrentInf >= DFU_ALT_SETTING) || (DfuObj.RuntimeToDfu == 1U)) {
+
+		/* Clear the flag , before entering into DFU mode from runtime mode */
+		if (DfuObj.RuntimeToDfu == 1U)
+			DfuObj.RuntimeToDfu = 0U;
+
 		/* Entering DFU_IDLE state */
-		XFsbl_DfuSetState(InstancePtr, STATE_DFU_IDLE);
+		XFsbl_DfuSetState(STATE_DFU_IDLE);
 	} else {
 		/* Entering APP_IDLE state */
-		XFsbl_DfuSetState(InstancePtr, STATE_APP_IDLE);
+		XFsbl_DfuSetState(STATE_APP_IDLE);
 	}
 }
 
 /*****************************************************************************
  * This function handles DFU heart and soul of DFU state machine.
  *
- * @param	InstancePtr is a pointer to XUsbPsu instance of the controller
  * @param	SetupData is a pointer to setup token of control transfer
  *
  * @return
@@ -590,99 +697,82 @@ void XFsbl_DfuSetIntf(struct Usb_DevData* InstancePtr, SetupPacket *SetupData)
  * @note		None.
  *
  ******************************************************************************/
-void XFsbl_DfuClassReq(struct Usb_DevData* InstancePtr, SetupPacket *SetupData)
+void XFsbl_DfuClassReq(SetupPacket *SetupData)
 {
-	int Result = XST_FAILURE;
+	Xil_AssertVoid(SetupData != NULL);
 	u32 RxBytesLeft;
-	static u8 DfuReply[DFU_STATUS_SIZE] = {0,};
+	s32 Result;
 
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(SetupData != NULL);
+	static u8 DfuReply[DFU_STATUS_SIZE]={0,};
 
 	switch(SetupData->bRequest) {
 		case DFU_DETACH:
 		{
-			XFsbl_DfuSetState(InstancePtr, STATE_APP_DETACH);
+			XFsbl_DfuSetState(STATE_APP_DETACH);
 		}
 		break;
 
 		case DFU_DNLOAD:
 		{
-			if(DfuObj.GotDnloadRqst == (u8)FALSE) {
-				DfuObj.GotDnloadRqst = (u8)TRUE;
-			}
-			if ((DfuObj.TotalTransfers == 0U) &&
-				(SetupData->wValue == 0U)) {
-				/* We are at the start of the data,
-				 * clear the download counter
-				 */
+			if (SetupData->wValue == 0U) {
+				/* we are the start of the data, clear the download counter  */
 				DfuObj.TotalBytesDnloaded = 0U;
 			}
 
-			RxBytesLeft = SetupData->wLength;
+			RxBytesLeft = (u32)(SetupData->wLength);
 
 			if(RxBytesLeft > 0U) {
-				Result = XUsbPsu_EpBufferRecv(
-					(struct XUsbPsu*)InstancePtr->PrivateData,
-					0U, &DfuVirtFlash[DfuObj.TotalBytesDnloaded],
-					RxBytesLeft);
-				DfuObj.TotalBytesDnloaded += RxBytesLeft;
-			}
-			else {
-				if (DfuObj.GotDnloadRqst == (u8)TRUE) {
-					DfuObj.CurrState =
-						STATE_DFU_IDLE;
-					DfuObj.GotDnloadRqst = (u8)FALSE;
-					DfuObj.TotalTransfers = 0U;
-				}
-			}
+				do {
+					Result = XUsbPsu_EpBufferRecv(&UsbInstance, 0U, &DfuVirtFlash[DfuObj.TotalBytesDnloaded],
+								RxBytesLeft);
+				}while(Result != XST_SUCCESS);
 
-			if((DfuObj.GotDnloadRqst == (u8)TRUE) &&
-				(Result == XST_SUCCESS)) {
-				DfuObj.CurrState =
-					STATE_DFU_DOWNLOAD_IDLE;
-				DfuObj.GotDnloadRqst = (u8)FALSE;
+				DfuObj.TotalBytesDnloaded += RxBytesLeft;
+				DfuObj.CurrState = STATE_DFU_DOWNLOAD_IDLE;
+				DfuObj.GotDnloadRqst = 0U;
+			} else {/*if (RxBytesLeft == 0U)*/
+				DfuObj.CurrState = STATE_DFU_IDLE;
+				DfuObj.GotDnloadRqst = 0U;
+				Result = XST_FAILURE;
 			}
 		}
-			break;
+
+		break;
+
 		case DFU_GETSTATUS:
 		{
-			if (DfuObj.GotDnloadRqst == (u8)TRUE) {
-				if (DfuObj.CurrState == STATE_DFU_IDLE ) {
-					DfuObj.CurrState =
-						STATE_DFU_DOWNLOAD_SYNC;
-				}
-				else if (DfuObj.CurrState ==
-						STATE_DFU_DOWNLOAD_SYNC) {
-					DfuObj.CurrState =
-						STATE_DFU_DOWNLOAD_BUSY;
-				}
-				else {
-					/*Do nothing */
-				}
+			if(DfuObj.CurrState == STATE_DFU_IDLE )
+			{
+				DfuObj.CurrState = STATE_DFU_DOWNLOAD_SYNC;
+				++DownloadDone;
+			}
+			else if (DfuObj.CurrState == STATE_DFU_DOWNLOAD_SYNC)
+			{
+				DfuObj.CurrState = STATE_DFU_DOWNLOAD_BUSY;
+			}
+			else
+			{
+				/*Misra C compliance*/
 			}
 			DfuReply[0] = DfuObj.CurrStatus;
 			DfuReply[4] = DfuObj.CurrState;
-			if (SetupData->wLength > 0U) {
-				Result = XUsbPsu_EpBufferSend(
-				(struct XUsbPsu*)InstancePtr->PrivateData,
-				0U, DfuReply, (u32)SetupData->wLength);
-				if (Result != XST_SUCCESS) {
-					goto END;
-				}
-			}
+
+			do {
+					Result = XUsbPsu_EpBufferSend(&UsbInstance, 0U, DfuReply, (u32)SetupData->wLength);
+
+			}while(Result != XST_SUCCESS);
+
 		}
-			break;
+		break;
+
 		default:
-			/* Unsupported command. Stall the end point. */
+		{
+			/* Unsupported command. Stall the end point.*/
 			DfuObj.CurrState = STATE_DFU_ERROR;
-			XUsbPsu_Ep0StallRestart(
-				(struct XUsbPsu*)InstancePtr->PrivateData);
-			break;
+			XUsbPsu_EpSetStall(&UsbInstance, 0U, XUSBPSU_EP_DIR_IN);
+		}
+		break;
 	}
-
-END:
-	return;
 }
 
 #endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.h
index 275c8a0306..93d9720efd 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_dfu_util.h
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2017 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
-
 /****************************************************************************/
 /**
 *
@@ -17,7 +37,6 @@
 * Ver   Who  Date     Changes
 * ----- ---- -------- -------------------------------------------------------
 * 1.0   bvikram  02/01/17 First release
-* 2.0   bvikram  09/20/20 Fix USB boot issue
 *
 * </pre>
 *
@@ -180,41 +199,17 @@ typedef struct{
 } __attribute__((__packed__))XFsblPs_UsbBosDesc;
 
 struct XFsblPs_DfuIf {
-	struct Usb_DevData* InstancePtr;
 	u8 CurrState;
 	u8 NextState;
 	u8 CurrStatus;
 	u8 GotReset;
-	u32 CurrentInf; /**< Current interface */
+	u32 CurrentInf; /* current interface */
 	u8 GotDnloadRqst;
-	u32 TotalTransfers;
 	u32 TotalBytesDnloaded;
-	volatile u8 DfuWaitForInterrupt;
-	u8 IsDfu;
+	u8 DfuWaitForInterrupt;
 	u8 RuntimeToDfu;
 };
 
-typedef struct {
-	u32 (*XFsblPs_Ch9SetupDevDescReply)(u8 *BufPtr, u32 BufferLen);
-	u32 (*XFsblPs_Ch9SetupCfgDescReply)(u8 *BufPtr, const u32 BufferLen);
-	u32 (*XFsblPs_Ch9SetupBosDescReply)(u8 *BufPtr, u32 BufferLen);
-	u32 (*XFsblPs_Ch9SetupStrDescReply)(u8 *BufPtr, const u32 BufferLen, u8 Index);
-	int (*XFsblPs_SetConfiguration)(struct Usb_DevData* InstancePtr,
-		SetupPacket *SetupData);
-	int (*XFsblPs_SetConfigurationApp)(const struct Usb_DevData* InstancePtr,
-		SetupPacket *SetupData);
-	void (*XFsblPs_SetInterfaceHandler)(struct Usb_DevData* InstancePtr,
-		SetupPacket *SetupData);
-	void (*XFsblPs_ClassReq)(struct Usb_DevData* InstancePtr,
-		SetupPacket *SetupData);
-	u32 (*XFsblPs_GetDescReply)(const struct Usb_DevData* InstancePtr,
-                SetupPacket *SetupData, u8 *BufPtr);
-}XFsbl_Ch9Func_Container;
-
-typedef struct {
-	XFsbl_Ch9Func_Container Ch9_func;
-	void * Data_ptr;
-}XFsbl_UsbCh9_Data;
 
 #define DFU_MAX_TRANSFER			1024U
 /* DFU status */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_error.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_error.h
index 42673ac9cf..c4966b1081 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_error.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_error.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -25,7 +45,6 @@
 * 5.0   ka   04/10/18 Added error codes for user-efuse revocation
 * 6.0   bkm  04/10/18 Added error codes for FMC_VADJ
 * 7.0	bsv	 08/27/19 Added error code for invalid image header size
-*
 * </pre>
 *
 * @note
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_exit.S b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_exit.S
index ff5cb8ff7f..c0dc592619 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_exit.S
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_exit.S
@@ -1,8 +1,29 @@
 /******************************************************************************
 *
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
+
 /*****************************************************************************/
 /**
 *
@@ -17,7 +38,6 @@
 * ----- ---- -------- -------------------------------------------------------
 * 1.00  kc   11/13/13 Initial release
 *       mus  02/26/19 Added support for armclang compiler
-*       dp   06/25/20 Added armclang support for Cortex-R5
 *
 * </pre>
 *
@@ -134,48 +154,7 @@ XFsbl_StartApp:
 	AREA |.exit|, CODE
 XFsbl_Exit
 
-#ifdef ARMR5
-	mov	 lr, r0 ;move the destination address into link register
-
-	mcr	 p15,0,r0,c7,c5,0 ;Invalidate Instruction cache
-	mcr	 p15,0,r0,c7,c5,6 ;Invalidate branch predictor array
-
-	dsb
-	isb ;make sure it completes
-
-	mrc     p15,0,r4,c1,c0,0 ;Read SCTLR
-	bic     r4, r4, #0x04  ;disable L1 I Cache
-	bic     r4, r4, #0x1000 ;Disable L1 D Cache
-	mcr	p15,0,r4,c1,c0,0 ;disable the DCache, ICache
-	isb ;make sure it completes
-
-	;set exception vector to HIVEC
-	;this is done because, in LOVEC we can not disable the MPU as
-	;OCM region is not present in default MPU regions when in LOVEC
-	mrc     p15, 0, r0, c1, c0, 0  ;Read SCTLR
-	orr	r0, r0, #0x2000
-	mcr	p15, 0, r0, c1, c0, 0
-	isb
-
-	;disable the MPU
-	mrc     p15,0,r4,c1,c0,0 ;Read SCTLR
-	bic     r4, r4, #0x01
-	mcr	p15,0,r4,c1,c0,0
-	isb
-
-	cmp r1, #0  ;exit to wfe
-	beq XFsbl_Loop
 
-	cmp r1, #2   ;x1 is 2 - exit in aarch32
-	beq XFsbl_StartApp
-
-	;x1 is 1 - exit in aarch64
-	mov r2, #3   ;request for warm reset and aarch64
-	dsb
-	isb
-	mcr	p15, 0, r2, c12, c0, 2 ;write to reset management register
-	isb
-#else
 	mov x30, x0 ; move the destination address into x30 register
 
 	tlbi ALLE3   ; invalidate All E3 translation tables
@@ -204,7 +183,7 @@ XFsbl_Exit
 	isb
 	msr RMR_EL3,x2 ; write to reset management register
 	isb
-#endif
+
 
 XFsbl_Loop
 	wfe				;wait for event
@@ -212,10 +191,6 @@ XFsbl_Loop
 
 
 XFsbl_StartApp
-#ifdef ARMR5
-	bx	lr;
-#else
 	br 	x30        ; branch to
-#endif
 	END
 #endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_handoff.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_handoff.c
index 7c632bd1ea..f32ac15385 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_handoff.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_handoff.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
  *
@@ -24,10 +44,6 @@
  *                     it is by passed.
  *       bv   03/17/17 Modified such that XFsbl_PmInit is done only duing
  *                     system reset
- * 3.0   ma   09/09/19 Update FSBL proc info reporting to PMU
- * 4.0   bsv  03/05/19 Restore value of SD_CDN_CTRL register before
- *                     handoff in FSBL
- *
  * </pre>
  *
  * @note
@@ -95,7 +111,6 @@ extern u8 R5LovecBuffer[32];
 extern u32 TcmSkipLength;
 extern PTRSIZE TcmSkipAddress;
 #endif
-extern u32 SdCdnRegVal;
 
 static u32 XFsbl_Is32BitCpu(u32 CpuSettings)
 {
@@ -723,7 +738,7 @@ u32 XFsbl_Handoff (const XFsblPs * FsblInstancePtr, u32 PartitionNum, u32 EarlyH
 	static u32 CpuIndexEarlyHandoff = 0;
 
 	/* Restoring the SD card detection signal */
-	XFsbl_Out32(IOU_SLCR_SD_CDN_CTRL, SdCdnRegVal);
+	XFsbl_Out32(IOU_SLCR_SD_CDN_CTRL, 0X0U);
 	PartitionHeader =
 			&FsblInstancePtr->ImageHeader.PartitionHeader[PartitionNum];
 
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
index 80a1314203..de166f8bd5 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 -18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -46,8 +66,9 @@ u32 XFsbl_HookBeforeBSDownload(void )
 	/**
 	 * Add the code here
 	 */
-
-
+/* TE Mod:*/
+  Status = TE_XFsbl_HookBeforeBSDownload();
+/* TE Mod: finished*/                 
 	return Status;
 }
 
@@ -59,7 +80,9 @@ u32 XFsbl_HookAfterBSDownload(void )
 	/**
 	 * Add the code here
 	 */
-
+/* TE Mod:*/
+  Status = TE_XFsbl_HookAfterBSDownload();
+/* TE Mod: finished*/            
 	return Status;
 }
 #endif
@@ -71,7 +94,9 @@ u32 XFsbl_HookBeforeHandoff(u32 EarlyHandoff)
 	/**
 	 * Add the code here
 	 */
-
+/* TE Mod:*/
+  Status = TE_XFsbl_HookBeforeHandoff(EarlyHandoff); 
+/* TE Mod: finished*/                
 	return Status;
 }
 
@@ -93,7 +118,9 @@ u32 XFsbl_HookBeforeFallback(void)
 	/**
 	 * Add the code here
 	 */
-
+/* TE Mod:*/
+  Status = TE_XFsbl_HookBeforeFallback(); 
+/* TE Mod: finished*/                   
 	return Status;
 }
 
@@ -118,20 +145,27 @@ u32 XFsbl_HookPsuInit(void)
 #endif
 
 	/* Add the code here */
-
-#ifdef XFSBL_ENABLE_DDR_SR
-	/* Check if DDR is in self refresh mode */
-	RegVal = Xil_In32(XFSBL_DDR_STATUS_REGISTER_OFFSET) &
-		DDR_STATUS_FLAG_MASK;
-	if (RegVal) {
-		Status = (u32)psu_init_ddr_self_refresh();
-	} else {
-		Status = (u32)psu_init();
-	}
-#else
-	Status = (u32)psu_init();
-#endif
-
+/* TE Mod:*/
+  Status = TE_XFsbl_HookPsuInit(); 
+  if (Status != XFSBL_SUCCESS) {
+     xil_printf("Error: TE_XFsbl_HookPsuInit failed\r\n");
+     goto END;
+  }
+
+// #ifdef XFSBL_ENABLE_DDR_SR
+	// /* Check if DDR is in self refresh mode */
+	// RegVal = Xil_In32(XFSBL_DDR_STATUS_REGISTER_OFFSET) &
+		// DDR_STATUS_FLAG_MASK;
+	// if (RegVal) {
+		// Status = (u32)psu_init_ddr_self_refresh();
+	// } else {
+		// Status = (u32)psu_init();
+	// }
+// #else
+	// Status = (u32)psu_init();
+// #endif
+  END:
+/* TE Mod: finished*/
 	if (XFSBL_SUCCESS != Status) {
 			XFsbl_Printf(DEBUG_GENERAL,"XFSBL_PSU_INIT_FAILED\n\r");
 			/**
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.h
index 604cb08f17..6cdc893ae9 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hooks.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -32,7 +52,10 @@ extern "C" {
 
 /***************************** Include Files *********************************/
 #include "xil_types.h"
-
+#include "xfsbl_hw.h"
+/* TE Mod:*/
+#include "te_xfsbl_hooks.h"
+/* TE Mod: finished*/
 /************************** Constant Definitions *****************************/
 
 /**************************** Type Definitions *******************************/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hw.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hw.h
index 0b0e257e10..31a4ea0356 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hw.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_hw.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -903,13 +923,9 @@ extern "C" {
 
 #ifdef ARMR5
 #define XFSBL_PS_DDR_INIT_START_ADDRESS	XFSBL_PS_DDR_START_ADDRESS_R5
-#if defined(XPAR_PSU_R5_DDR_1_S_AXI_BASEADDR)
-#define XFSBL_PS_HI_DDR_START_ADDRESS	XPAR_PSU_R5_DDR_1_S_AXI_BASEADDR
-#define XFSBL_PS_HI_DDR_END_ADDRESS XPAR_PSU_R5_DDR_1_S_AXI_HIGHADDR
-#endif
 #else
 #define XFSBL_PS_DDR_INIT_START_ADDRESS	XFSBL_PS_DDR_START_ADDRESS
-#if defined(XPAR_PSU_DDR_1_S_AXI_BASEADDR)
+#if defined(XPAR_PSU_DDR_1_S_AXI_BASEADDR) && defined (ARMA53_64)
 #define XFSBL_PS_HI_DDR_START_ADDRESS	XPAR_PSU_DDR_1_S_AXI_BASEADDR
 #define XFSBL_PS_HI_DDR_END_ADDRESS XPAR_PSU_DDR_1_S_AXI_HIGHADDR
 #endif
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.c
index 11f18ea7d8..6a2468627b 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -29,8 +49,6 @@
 *                     eFUSE bit is set, if not encrypted FSBL throw an error.
 *       mus  02/26/19 Added support for armclang compiler
 *       bsv  07/05/19 Remove MD5 checksum related code
-*       bsv  07/19/19 Rectify the TCM limit used for validating DDR address
-*                     by R5 FSBL
 *
 * </pre>
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.h
index 5675f17eca..56b5a958cf 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_image_header.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -32,8 +52,6 @@
 *       vns  03/07/18 Added BHDR attribute mask for PUF and macros for
 *                     boot header size.
 *       bsv  07/05/19 Remove MD5 checksum related macro
-*       bsv  07/19/19 Rectify the TCM limit used for validating DDR address
-*                     by R5 FSBL
 *
 * </pre>
 *
@@ -61,7 +79,6 @@ extern "C" {
 /**
  * Boot header field offset
  */
-#define XIH_BH_ENC_STS_OFFSET	(0x28U)
 #define XIH_BH_IH_OFFSET		(0x3CU)
 #define XIH_BH_TOTAL_PFW_LENGTH_OFFSET		(0x38U)
 #define XIH_BH_IMAGE_ATTRB_OFFSET	(0x44U)
@@ -71,7 +88,6 @@ extern "C" {
 #define XIH_BH_IMAGE_ATTRB_RSA_MASK	(0xC000U)
 #define XIH_BH_IMAGE_ATTRB_PUF_BH_MASK	(0x00C0U)
 #define XIH_BH_IMAGE_ATTRB_SHA2_MASK	(0x3000U)
-#define XIH_BH_IMAGE_ATTRB_AUTH_ONLY_MASK	(0x0030U)
 #define XIH_BH_IV_OFFSET       		(0xA0U)
 #define XIH_BH_IV_LENGTH   			(0x10U)
 
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_initialization.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_initialization.c
index 15f1860d8d..ee3ecafbcb 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_initialization.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_initialization.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
  ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -38,12 +58,6 @@
 * 5.0   mn   07/06/18 Add DDR initialization support for new DDR DIMM part
 *       mus  02/26/19 Added support for armclang compiler
 *       vns  03/14/19 Setting AES and SHA hardware engines into reset.
-* 6.0   bsv  08/27/19 Added check to ensure padding in image header does not
-*                     exceed allotted buffer in OCM
-* 7.0   bsv  03/05/20 Restore value of SD_CDN_CTRL register before handoff
-*       ma   03/19/20 Update the status of FSBL image encryption in PMU Global
-*                     register
-*
 * </pre>
 *
 * @note
@@ -130,7 +144,7 @@ u8 *ImageHdr = ReadBuffer;
 extern u8 AuthBuffer[XFSBL_AUTH_BUFFER_SIZE];
 extern u32 Iv[XIH_BH_IV_LENGTH / 4U];
 #endif
-u32 SdCdnRegVal;
+
 /****************************************************************************/
 /**
  * This function is used to save the data section into duplicate data section
@@ -625,17 +639,15 @@ static u32 XFsbl_ResetValidation(void)
 {
 	u32 Status;
 	u32 FsblErrorStatus;
-#ifdef XFSBL_WDT_PRESENT
 	u32 ResetReasonValue;
 	u32 ErrStatusRegValue;
-#endif
+
 	/**
 	 *  Read the Error Status register
 	 *  If WDT reset, do fallback
 	 */
 	FsblErrorStatus = XFsbl_In32(XFSBL_ERROR_STATUS_REGISTER_OFFSET);
 
-#ifdef XFSBL_WDT_PRESENT
 	ResetReasonValue = XFsbl_In32(CRL_APB_RESET_REASON);
 
 	/**
@@ -645,10 +657,13 @@ static u32 XFsbl_ResetValidation(void)
 	if ((ResetReasonValue & CRL_APB_RESET_REASON_PMU_SYS_RESET_MASK)
 			== CRL_APB_RESET_REASON_PMU_SYS_RESET_MASK) {
 		ErrStatusRegValue = XFsbl_In32(PMU_GLOBAL_ERROR_STATUS_1);
-		if(((ErrStatusRegValue & XFSBL_WDT_MASK) == XFSBL_WDT_MASK) &&
+		if(((ErrStatusRegValue& PMU_GLOBAL_ERROR_STATUS_1_LPD_SWDT_MASK)
+			== PMU_GLOBAL_ERROR_STATUS_1_LPD_SWDT_MASK) &&
 			(FsblErrorStatus == XFSBL_RUNNING)) {
+#ifdef XFSBL_WDT_PRESENT
 			/* Clear the SWDT0/1 reset error */
 			XFsbl_Out32(PMU_GLOBAL_ERROR_STATUS_1, XFSBL_WDT_MASK);
+#endif
 		/**
 		 * reset is due to System WDT.
 		 * Do a fallback
@@ -658,7 +673,7 @@ static u32 XFsbl_ResetValidation(void)
 		goto END;
 		}
 	}
-#endif
+
 	/**
 	 * Mark FSBL running in error status register to
 	 * detect the WDT reset while FSBL execution
@@ -674,9 +689,7 @@ static u32 XFsbl_ResetValidation(void)
 	 */
 
 	Status = XFSBL_SUCCESS;
-#ifdef XFSBL_WDT_PRESENT
 END:
-#endif
 	return Status;
 }
 
@@ -791,7 +804,6 @@ static u32 XFsbl_SystemInit(XFsblPs * FsblInstancePtr)
 	 * This will ensure that SD controller doesn't end up waiting for long,
 	 * fixed durations for card to be stable.
 	 */
-	SdCdnRegVal = XFsbl_In32(IOU_SLCR_SD_CDN_CTRL);
 	XFsbl_Out32(IOU_SLCR_SD_CDN_CTRL,
 			(IOU_SLCR_SD_CDN_CTRL_SD1_CDN_CTRL_MASK |
 					IOU_SLCR_SD_CDN_CTRL_SD0_CDN_CTRL_MASK));
@@ -1113,7 +1125,6 @@ static u32 XFsbl_ValidateHeader(XFsblPs * FsblInstancePtr)
 	u32 FlashImageOffsetAddress;
 	u32 EfuseCtrl;
 	u32 ImageHeaderTableAddressOffset=0U;
-	u32 FsblEncSts = 0U;
 #ifdef XFSBL_SECURE
 	u32 Size;
 	u32 AcOffset=0U;
@@ -1170,27 +1181,6 @@ static u32 XFsbl_ValidateHeader(XFsblPs * FsblInstancePtr)
 					XIH_BH_IMAGE_ATTRB_OFFSET);
 	FsblInstancePtr->BootHdrAttributes = BootHdrAttrb;
 
-	/*
-	 * Update PMU Global general storage register5 bit 3 with FSBL encryption
-	 * status if either FSBL encryption status in boot header is true or
-	 * ENC_ONLY eFuse bit is programmed.
-	 *
-	 * FSBL encryption information in boot header:
-	 * If authenticate only bits 5:4 are set, boot image is only RSA signed
-	 * though encryption status in BH is non-zero.
-	 * Boot image is decrypted only when BH encryption status is not 0x0 and
-	 * authenticate only bits value is other than 0x3
-	 */
-	if (((Xil_In32((UINTPTR)ReadBuffer + XIH_BH_ENC_STS_OFFSET) != 0x0U) &&
-			((BootHdrAttrb & XIH_BH_IMAGE_ATTRB_AUTH_ONLY_MASK) !=
-					XIH_BH_IMAGE_ATTRB_AUTH_ONLY_MASK)) ||
-			((XFsbl_In32(EFUSE_SEC_CTRL) & EFUSE_SEC_CTRL_ENC_ONLY_MASK) !=
-					0x0U)) {
-		FsblEncSts = XFsbl_In32(PMU_GLOBAL_GLOB_GEN_STORAGE5) |
-				XFSBL_FSBL_ENCRYPTED_MASK;
-		XFsbl_Out32(PMU_GLOBAL_GLOB_GEN_STORAGE5, FsblEncSts);
-	}
-
 	/**
 	 * Read the Image Header Table offset from
 	 * Boot Header
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.c
index 5c4a3cf2e4..799fff111c 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -338,12 +358,23 @@ void XFsbl_PrintFsblBanner(void )
 	 */
 #if !defined(XFSBL_PERF) || defined(FSBL_DEBUG) || defined(FSBL_DEBUG_INFO) \
 			|| defined(FSBL_DEBUG_DETAILED)
+  // TE Mod : 
 	XFsbl_Printf(DEBUG_PRINT_ALWAYS,
-                 "Xilinx Zynq MP First Stage Boot Loader \n\r");
+                 "\r\n--------------------------------------------------------------------------------\r\n");  
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS,
+                 "Xilinx Zynq MP First Stage Boot Loader (TE modified) \n\r");
 	XFsbl_Printf(DEBUG_PRINT_ALWAYS,
                  "Release %d.%d   %s  -  %s\r\n",
                  SDK_RELEASE_YEAR, SDK_RELEASE_QUARTER,__DATE__,__TIME__);
-
+                 
+	/* Build Device name and print it */
+  char DevName[20U];
+	(void)XFsbl_Strcpy(DevName, "XCZU");
+	(void)XFsbl_Strcat(DevName, XFsbl_GetSiliconIdName());
+	(void)XFsbl_Strcat(DevName, XFsbl_GetProcEng());
+	XFsbl_Printf(DEBUG_PRINT_ALWAYS, "Device Name: %s\n\r", DevName);  
+                 
+// TE Mod finished
 	if(FsblInstance.ResetReason == XFSBL_PS_ONLY_RESET) {
 		XFsbl_Printf(DEBUG_GENERAL,"Reset Mode	:	PS Only Reset\r\n");
 	} else if (XFSBL_MASTER_ONLY_RESET == FsblInstance.ResetReason) {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.h
index 44034b62cb..d23e8cd24f 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_main.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -90,7 +110,7 @@ typedef struct {
 /***************** Macros (Inline Functions) Definitions *********************/
 
 /* SDK release version */
-#define SDK_RELEASE_YEAR	2020
+#define SDK_RELEASE_YEAR	2019
 #define SDK_RELEASE_QUARTER	2
 
 #define XFSBL_RUNNING			(0xFFFFU)
@@ -163,7 +183,6 @@ typedef struct {
 #define XFSBL_STATE_PROC_SHIFT			(0x1U)
 
 #define XFSBL_STATE_PROC_INFO_MASK		(0x3U << XFSBL_STATE_PROC_SHIFT)
-#define XFSBL_FSBL_ENCRYPTED_MASK		(0x8U)
 
 
 /************************** Function Prototypes ******************************/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.c
index 92d83e687c..2a5c161220 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.h
index 20d8a76930..c6f598f05c 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.c
index fba2d7ca4f..ffc3848a88 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.h
index 31b8994cbe..2fc50dedbd 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_misc_drivers.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_nand.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_nand.c
index e67296d333..c142ae246b 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_nand.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_nand.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c
index d7700c4909..5d8793e2e9 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 19 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -36,9 +56,6 @@
 *                     internal memory), using same way for non authenticated
 *                     case as well.
 *       mus  02/26/19 Added support for armclang compiler.
-*       skd  02/02/20 Added register writes to PMU GLOBAL to indicate PL configuration
-*       har  09/22/20 Removed checks for IsCheckSumEnabled with authentication
-*                     and encryption
 *
 * </pre>
 *
@@ -66,13 +83,6 @@
 #define XFSBL_R5_LOVEC		(u32)(0x0U)
 #define XFSBL_SET_R5_SCTLR_VECTOR_BIT   (u32)(1<<13)
 #define XFSBL_PARTITION_IV_MASK  (0xFFU)
-#ifdef XFSBL_BS
-#define XFSBL_STATE_MASK	0x00FF0000U
-#define XFSBL_STATE_SHIFT	16U
-#define XFSBL_FIRMWARE_STATE_UNKNOWN	0U
-#define XFSBL_FIRMWARE_STATE_SECURE	1U
-#define XFSBL_FIRMWARE_STATE_NONSECURE	2U
-#endif
 
 /************************** Function Prototypes ******************************/
 static u32 XFsbl_PartitionHeaderValidation(XFsblPs * FsblInstancePtr,
@@ -88,18 +98,16 @@ static u32 XFsbl_GetLoadAddress(u32 DestinationCpu, PTRSIZE * LoadAddressPtr,
 		u32 Length);
 static void XFsbl_CheckPmuFw(const XFsblPs * FsblInstancePtr, u32 PartitionNum);
 
-#ifdef XFSBL_BS
-static void XFsbl_SetBSSecureState(u32 State);
-#endif
-
 #ifdef XFSBL_ENABLE_DDR_SR
 static void XFsbl_PollForDDRReady(void);
 #endif
 
+#ifdef XFSBL_SECURE
 static u32 XFsbl_CalcualteCheckSum(XFsblPs* FsblInstancePtr,
 		PTRSIZE LoadAddress, u32 PartitionNum);
 static u32 XFsbl_CalcualteSHA(const XFsblPs* FsblInstancePtr,
 		PTRSIZE LoadAddress, u32 PartitionNum, u32 ShaType);
+#endif
 
 #ifdef ARMR5
 static void XFsbl_SetR5ExcepVectorHiVec(void);
@@ -574,21 +582,6 @@ END:
 	return Status;
 }
 
-/*****************************************************************************/
-/**
- * This function validates the load address for R5 elfs and maps it to global
- * physical TCM address space so that any cpu can access it globally.
- *
- * @param       DestinationCpu is the cpu on which partition will run
- *
- * @param       LoadAddress will be updated according to the cpu and address
- *
- * @param       Length of the data to be copied. This is required only to
- *              check for error cases
- *
- * @return      returns the error codes described in xfsbl_error.h on any error
- *                      returns XFSBL_SUCCESS on success
- *****************************************************************************/
 static u32 XFsbl_GetLoadAddress(u32 DestinationCpu, PTRSIZE * LoadAddressPtr, u32 Length)
 {
 	u32 Status;
@@ -684,7 +677,7 @@ END:
  * cpu. For R5 cpu's TCM address is remapped to the higher TCM address
  * so that any cpu can globally access it
  *
- * @param	DestinationCpu is the cpu on which partition will run
+ * @param	DestinationCpu is the cpu which partition will run
  *
  * @param	LoadAddress will be updated according to the cpu and address
  *
@@ -1117,7 +1110,7 @@ END:
 static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 						u32 PartitionNum)
 {
-	u32 Status = XFSBL_FAILURE;
+	u32 Status;
 	u32 IsEncryptionEnabled;
 	u32 IsAuthenticationEnabled;
 	u32 IsChecksumEnabled;
@@ -1126,13 +1119,13 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 	u32 ExecState;
 	u32 CpuNo;
 	XFsblPs_PartitionHeader * PartitionHeader;
-	u32 Length;
 
 #if defined(XFSBL_SECURE)
 	s32 SStatus;
 	u32 FsblIv[XIH_BH_IV_LENGTH / 4U] = { 0 };
 	u8 *IvPtr = (u8 *)&FsblIv[2];
 	u32 UnencryptedLength = 0U;
+	u32 Length;
 	static XSecure_Aes SecureAes;
 #ifdef XFSBL_BS
 	XFsblPs_PlPartition PlParams = {0};
@@ -1242,11 +1235,9 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 #endif
 
 #ifdef XFSBL_SECURE
-	if ((IsChecksumEnabled == TRUE) || (IsAuthenticationEnabled == TRUE) ||
-			(IsEncryptionEnabled == TRUE))	{
-#else
-	if ((IsChecksumEnabled == TRUE)) {
-#endif
+	if ((IsAuthenticationEnabled == TRUE) || (IsEncryptionEnabled == TRUE) ||
+			(IsChecksumEnabled == TRUE))
+	{
 		Length = PartitionHeader->TotalDataWordLength * 4U;
 		Status = XFsbl_GetLoadAddress(DestinationCpu,
 				&LoadAddress, Length);
@@ -1255,6 +1246,7 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 			goto END;
 		}
 	}
+#endif
 
 #ifdef XFSBL_BS
 	if ((DestinationDevice == XIH_PH_ATTRB_DEST_DEVICE_PL) &&
@@ -1317,7 +1309,9 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 #endif
 
 	/* Checksum verification */
-	if (IsChecksumEnabled == TRUE) {
+	if (IsChecksumEnabled == TRUE)
+	{
+#ifdef XFSBL_SECURE
 		Status = XFsbl_CalcualteCheckSum(FsblInstancePtr,
 				LoadAddress, PartitionNum);
 		if (Status != XFSBL_SUCCESS) {
@@ -1326,6 +1320,11 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 			Status = XFSBL_ERROR_PARTITION_CHECKSUM_FAILED;
 			goto END;
 		}
+#else
+		XFsbl_Printf(DEBUG_GENERAL,"XFSBL_ERROR_SECURE_NOT_ENABLED \r\n");
+		Status = XFSBL_ERROR_SECURE_NOT_ENABLED;
+		goto END;
+#endif
 	}
 
 	/**
@@ -1604,17 +1603,6 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 		/* Reset PL, if configured for */
 		(void)psu_ps_pl_reset_config_data();
 
-		/* Update PMU_GLOBAL_GEN_STORE Register */
-#ifdef XFSBL_SECURE
-		if ((IsAuthenticationEnabled == TRUE) || (IsEncryptionEnabled == TRUE))
-		{
-			XFsbl_SetBSSecureState(XFSBL_FIRMWARE_STATE_SECURE);
-		} else
-#endif
-		{
-			XFsbl_SetBSSecureState(XFSBL_FIRMWARE_STATE_NONSECURE);
-		}
-
 		/**
 		 * Fsbl hook after bit stream download
 		 */
@@ -1649,6 +1637,7 @@ static u32 XFsbl_PartitionValidation(XFsblPs * FsblInstancePtr,
 		}
 	}
 
+	Status = XFSBL_SUCCESS;
 END:
 	return Status;
 }
@@ -1721,26 +1710,7 @@ static void XFsbl_CheckPmuFw(const XFsblPs* FsblInstancePtr, u32 PartitionNum)
 
 }
 
-#ifdef XFSBL_BS
-/*****************************************************************************/
-/** Sets the library firmware state
- *
- * @param	State BS firmware state
- *
- * @return	None
- *****************************************************************************/
-static void XFsbl_SetBSSecureState(u32 State)
-{
-	u32 RegVal;
-
-	/* Set Firmware State in PMU GLOBAL GEN STORAGE Register */
-	RegVal = Xil_In32(PMU_GLOBAL_GLOB_GEN_STORAGE5);
-	RegVal &= ~XFSBL_STATE_MASK;
-	RegVal |= State << XFSBL_STATE_SHIFT;
-	Xil_Out32(PMU_GLOBAL_GLOB_GEN_STORAGE5, RegVal);
-}
-#endif
-
+#ifdef XFSBL_SECURE
 /*****************************************************************************/
 /**
  * This function validates the partition
@@ -1910,6 +1880,7 @@ static u32 XFsbl_CalcualteSHA(const XFsblPs * FsblInstancePtr, PTRSIZE LoadAddre
 	}
 	return Status;
 }
+#endif  /* end of XFSBL_SECURE */
 
 #ifdef XFSBL_ENABLE_DDR_SR
 /*****************************************************************************/
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.c
index 27260949ef..38adc86f58 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.c
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2017 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
@@ -45,9 +65,6 @@
 *                        XSecure_RsaPublicEncrypt, as XSecure_RsaDecrypt is
 *                        deprecated, also calls to secure stream switch
 *                        are modified
-*       har     01/03/20 Added checks to verify the value of XSecure_SssAes
-* 5.0   har     01/16/20 Added checks for Status of SSS configuration when AES
-*                        engine is the Resource
 *
 * </pre>
 *
@@ -346,7 +363,7 @@ static u32 XFsbl_ReAuthenticationBlock(XFsblPs_PlPartition *PartitionParams,
 				Len = HashDataLen;
 			}
 			Offset = (UINTPTR)Address +
-				(u64)((u64)PartitionParams->ChunkSize * (u64)Index);
+				(u64)(PartitionParams->ChunkSize * Index);
 
 			/* Copy from DDR or flash to Buffer */
 			Status = XFsbl_CopyData(PartitionParams,
@@ -481,7 +498,7 @@ static u32 XFsbl_PlSignVer(XFsblPs_PlPartition *PartitionParams,
 			Len = HashDataLen;
 		}
 		Offset = (u64)BlockAdrs +
-			(u64)((u64)PartitionParams->ChunkSize * (u64)Index);
+			(u64)(PartitionParams->ChunkSize * Index);
 
 		Status = XFsbl_CopyData(PartitionParams,
 			PartitionParams->ChunkBuffer, (u8 *)(UINTPTR)Offset, Len);
@@ -740,11 +757,8 @@ static u32 XFsbl_DecrptSetUpNextBlk(XFsblPs_PlPartition *PartitionParams,
 			(UINTPTR)XSECURE_CSU_AES_IV_0_OFFSET);
 
 	/* Configure the SSS for AES. */
-	Status = XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
+	XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
 					XSECURE_SSS_PCAP);
-	if(Status != XFSBL_SUCCESS) {
-		goto END;
-	}
 
 	/* Start the message. */
 	XSecure_WriteReg(PartitionParams->PlEncrypt.SecureAes->BaseAddress,
@@ -762,7 +776,7 @@ static u32 XFsbl_DecrptSetUpNextBlk(XFsblPs_PlPartition *PartitionParams,
 	XSecure_WriteReg(PartitionParams->PlEncrypt.SecureAes->BaseAddress,
 					XSECURE_CSU_AES_KUP_WR_OFFSET, 0x0);
 
-END:
+
 	return Status;
 
 }
@@ -805,11 +819,8 @@ static u32 XFsbl_DecrptPl(XFsblPs_PlPartition *PartitionParams,
 				XCSUDMA_SRC_CHANNEL, &ConfigurValues);
 
 		/* Configure AES engine */
-		Status = XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
+		XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
 					XSECURE_SSS_PCAP);
-		if(Status != XFSBL_SUCCESS) {
-			goto END;
-		}
 
 		/* Send whole chunk of data to AES */
 		if ((Size <=
@@ -911,7 +922,6 @@ static u32 XFsbl_DecrptPl(XFsblPs_PlPartition *PartitionParams,
 
 	} while (Size != 0x00);
 
-END:
 	return Status;
 
 }
@@ -1011,12 +1021,8 @@ static u32 XFsbl_DecrptPlChunks(XFsblPs_PlPartition *PartitionParams,
 	else  if (PartitionParams->Hdr != 0x00) {
 
 		/* Configure AES engine */
-		Status = XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
+		XSecure_SssAes(&PartitionParams->SssInstance, XSECURE_SSS_DMA0,
 					XSECURE_SSS_PCAP);
-		if(Status != XFSBL_SUCCESS) {
-			goto END;
-		}
-
 
 		XFsbl_CopyData(PartitionParams,
 		(u8 *)(PartitionParams->SecureHdr + PartitionParams->Hdr),
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.h
index 7b1314bee8..15f6b7a65d 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_plpartition_valid.h
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2017 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
 *
@@ -22,10 +42,6 @@
 *                        another member(Hdr) to store size of data stored.
 * 3.0   vns     03/12/19 Added instance to XSecure_Sss structure in
 *                        XFsblPs_PlPartition structure.
-* 4.0   har     06/17/20 Removed references to unused algorithms
-* 5.0   har     01/16/20 Added checks for Status of SSS configuration when AES
-*                        engine is the Resource
-*
 * </pre>
 *
 ******************************************************************************/
@@ -52,7 +68,7 @@ extern "C" {
  * @{
  */
 typedef struct {
-	u8 AuthType;	/**< Type of Authentication used */
+	u8 AuthType;	/**< Type of Authentication used SHA2/SHA3 */
 	u8 *AuthCertBuf;/**< Buffer to store authentication certificate */
 	u32 AcOfset;	/**< Offset of first authentication certificate
 			  *  of bitstream */
@@ -102,6 +118,7 @@ u32 XFsbl_SecPlPartition(XFsblPs * FsblInstancePtr,
 /******************************************************************************/
 #ifdef __cplusplus
 }
+
 #endif
 
 #endif /* End of protection macro */
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.c
index 0b6aac4624..f9770af990 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -24,7 +44,6 @@
 * 4.0   tjs  10/16/18 Added support for QPI mode in Macronix flash parts.
 *       sk   03/13/19 Added dual parallel support and QPI support for 24bit
 *                     boot mode for Macronix flash parts.
-* 5.0   bsv  11/15/20 Added Macronix 2G flash support
 *
 * </pre>
 *
@@ -172,9 +191,7 @@ static u32 FlashReadID(XQspiPsu *QspiPsuPtr)
 			|| (ReadBuffer[2] == MACRONIX_FLASH_1_8_V_SIZE_ID_1G)) {
 		QspiFlashSize = FLASH_SIZE_1G;
 		XFsbl_Printf(DEBUG_INFO, "1G Bits\r\n");
-	} else if ((ReadBuffer[2] == FLASH_SIZE_ID_2G)
-			|| (ReadBuffer[2] == MACRONIX_FLASH_SIZE_ID_2G)
-			|| (ReadBuffer[2] == MACRONIX_FLASH_1_8_V_SIZE_ID_2G)) {
+	} else if (ReadBuffer[2] == FLASH_SIZE_ID_2G) {
                 QspiFlashSize = FLASH_SIZE_2G;
                 XFsbl_Printf(DEBUG_INFO, "2G Bits\r\n");
 	}else {
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.h
index b37a657690..342206d9ea 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_qspi.h
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -19,13 +39,7 @@
 * 1.00  kc   10/21/13 Initial release
 * 2.00  sg   12/03/15 Added GQSPI driver support
 *                     32Bit boot mode support
-* 3.0   bv   12/02/16 Made compliance to MISRAC 2012 guidelines
-*       ds   01/03/17 Add support for Micron QSPI 2G part
-* 4.0   tjs  10/16/18 Added support for QPI mode in Macronix flash parts.
-*       sk   03/13/19 Added dual parallel support and QPI support for 24bit
-*                     boot mode for Macronix flash parts.
-* 5.0   bsv  11/15/20 Added Macronix 2G flash support
-*
+* 3.0   ds   01/03/17 Add support for Micron QSPI 2G part
 * </pre>
 *
 * @note
@@ -165,8 +179,6 @@ extern "C" {
 /* Macronix size constants are different for 512M and 1G */
 #define MACRONIX_FLASH_SIZE_ID_512M		(0x1AU)
 #define MACRONIX_FLASH_SIZE_ID_1G		(0x1BU)
-#define MACRONIX_FLASH_SIZE_ID_2G		(0x1CU)
-#define MACRONIX_FLASH_1_8_V_SIZE_ID_2G		(0x3CU)
 #define MACRONIX_FLASH_1_8_V_SIZE_ID_1G  	(0x3BU)
 #define MACRONIX_FLASH_1_8_V_MX25_ID_256	(0x39U)
 #define MACRONIX_FLASH_1_8_V_MX66_ID_512	(0x3AU)
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_rsa_sha.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_rsa_sha.c
index 39b9c001f5..eff08560ab 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_rsa_sha.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_rsa_sha.c
@@ -1,15 +1,36 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 18 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 *******************************************************************************/
-
 /*****************************************************************************/
 /**
  *
  * @file xfsbl_rsa_sha.c
  *
- * This contains code for the RSA and SHA3 functionality.
- * For SHA3 CSU h/w will be used.
+ * This contains code for the RSA and SHA functionality.
+ * If the Hash type is SHA3 then CSU h/w will be used
+ * else we will use SoftSHA256 s/w library for SHA2-256.
  * For RSA-4096 we will always use CSU h/w.
  * <pre>
  * MODIFICATION HISTORY:
@@ -20,7 +41,6 @@
  * 2.0   bv   12/02/16  Made compliance to MISRAC 2012 guidelines
  * 3.0   vns  01/23/18  Added XFsbl_Sha3PadSelect() API to change SHA3 padding
  *                      to KECCAK SHA3 padding.
- * 4.0   har  06/17/20  Removed references to unused algorithms
  *
  * </pre>
  *
@@ -30,6 +50,7 @@
 
 /***************************** Include Files *********************************/
 #include "xfsbl_authentication.h"
+#ifdef XFSBL_SECURE
 
 /************************** Constant Definitions *****************************/
 
@@ -59,7 +80,6 @@ void XFsbl_ShaDigest(const u8 *In, const u32 Size, u8 *Out, u32 HashLen)
 	}
 }
 
-#ifdef XFSBL_SECURE
 /*****************************************************************************
  *
  * This function selects the padding type to be used for SHA3 hash calculation
@@ -70,7 +90,7 @@ void XFsbl_ShaDigest(const u8 *In, const u32 Size, u8 *Out, u32 HashLen)
  *              XST_FAILURE if selection is failed.
  *
  ******************************************************************************/
-u32 XFsbl_Sha3PadSelect(XSecure_Sha3PadType PadType)
+u32 XFsbl_Sha3PadSelect(u8 PadType)
 {
 	u32 Status;
 
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_sd.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_sd.c
index 1e2e494326..e10642b799 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_sd.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_sd.c
@@ -1,9 +1,29 @@
 /******************************************************************************
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2015 - 17 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 
-
 /*****************************************************************************/
 /**
 *
@@ -63,7 +83,7 @@ u32 XFsbl_SdInit(u32 DeviceFlags)
 	static FATFS fatfs;
 	u32 Status;
 	FRESULT rc;
-	char buffer[32U]={0U};
+	char buffer[32];
 	char *boot_file = buffer;
 	u32 MultiBootOffset;
 	u32 DrvNum;
@@ -97,7 +117,7 @@ u32 XFsbl_SdInit(u32 DeviceFlags)
 	 */
 	XFsbl_MakeSdFileName(boot_file, MultiBootOffset, DrvNum);
 
-	if(boot_file[0U]!=0U) {
+	if(boot_file!=NULL) {
 		rc = f_open(&fil, boot_file, (BYTE)FA_READ);
 		if (rc!=FR_OK) {
 		XFsbl_Printf(DEBUG_INFO,
@@ -110,7 +130,6 @@ u32 XFsbl_SdInit(u32 DeviceFlags)
 	else
 	{
 		Status = XFSBL_ERROR_SD_F_OPEN;
-		goto END;
 	}
 
 	Status = XFSBL_SUCCESS;
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_32.S b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_32.S
index c04affd3b9..6dbf4b7807 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_32.S
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_32.S
@@ -1,9 +1,28 @@
 /******************************************************************************
 *
-* Copyright (c) 2015 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+* Copyright (C) 2015 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
-
 /*****************************************************************************/
 /*
 * @file xfsbl_translation_table.S
@@ -18,7 +37,6 @@
 * Ver   Who  Date     Changes
 * ----- ---- -------- ---------------------------------------------------
 * 5.2	pkp  28/05/15 First release
-*
 * </pre>
 *
 * @note
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_64.S b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_64.S
index 68158abf99..39610fe10f 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_64.S
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_translation_table_a53_64.S
@@ -1,7 +1,27 @@
 /******************************************************************************
 *
-* Copyright (c) 2014 - 2020 Xilinx, Inc. All rights reserved.
-* SPDX-License-Identifier: MIT
+* Copyright (C) 2014 - 2015 Xilinx, Inc. All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
 /*****************************************************************************/
 /**
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.c b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.c
index 1d5d4ad93d..7861dd2589 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.c
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.c
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2017 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
-
 /****************************************************************************/
 /**
 *
@@ -17,7 +37,6 @@
 * Ver   Who  Date     Changes
 * ----- ---- -------- -------------------------------------------------------
 * 1.0   bvikram  02/01/17 First release
-* 2.0   bvikram  09/30/20 Fix USB boot issue
 *
 * </pre>
 *
@@ -38,22 +57,20 @@
 /************************** Constant Definitions ****************************/
 
 #define XFSBL_USB_DEVICE_ID		XPAR_XUSBPSU_0_DEVICE_ID
-#define XFSBL_REQ_REPLY_LEN		256U	/**< Max size of reply buffer. */
+#define XFSBL_REQ_REPLY_LEN		1024U	/**< Max size of reply buffer. */
 #define XFSBL_DOWNLOAD_COMPLETE		2U
 
 
 /************************** Function Prototypes ******************************/
-static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupData);
+static void XFsbl_StdDevReq(SetupPacket *SetupData);
 static void XFsbl_Ch9Handler(struct Usb_DevData *InstancePtr, SetupPacket *SetupData);
 
 /************************** Variable Definitions *****************************/
-struct Usb_DevData UsbInstance;
-static struct XUsbPsu UsbPrivateData;
+struct XUsbPsu UsbInstance;
 u8* DfuVirtFlash = (u8*)XFSBL_DDR_TEMP_BUFFER_ADDRESS;
 u32 DownloadDone = 0U;
 extern struct XFsblPs_DfuIf DfuObj;
 extern XCsuDma CsuDma;
-extern XFsbl_UsbCh9_Data Dfu_data;
 
 /*****************************************************************************
 * This function initializes the USB interface.
@@ -79,8 +96,7 @@ u32 XFsbl_UsbInit(u32 DeviceFlags)
 		goto END;
 	}
 
-	(void)memset(&UsbInstance, 0, sizeof(UsbInstance));
-	(void)memset(&UsbPrivateData, 0, sizeof(struct XUsbPsu));
+	(void)memset(&UsbInstance,0,sizeof(UsbInstance));
 	(void)memset(&DfuObj, 0, sizeof(DfuObj));
 
 	UsbConfigPtr = XUsbPsu_LookupConfig(XFSBL_USB_DEVICE_ID);
@@ -89,53 +105,36 @@ u32 XFsbl_UsbInit(u32 DeviceFlags)
 		goto END;
 	}
 
-	UsbPrivateData.AppData = &UsbInstance;
-	UsbInstance.PrivateData = (void*)&UsbPrivateData;
-
-	SStatus = XUsbPsu_CfgInitialize(
-			(struct XUsbPsu*)UsbInstance.PrivateData,
-			UsbConfigPtr, UsbConfigPtr->BaseAddress);
+	SStatus = XUsbPsu_CfgInitialize(&UsbInstance, UsbConfigPtr,
+					UsbConfigPtr->BaseAddress);
 	if (XST_SUCCESS != SStatus) {
 		Status = XFSBL_FAILURE;
 		goto END;
 	}
 
-	XUsbPsu_SetSpeed(UsbInstance.PrivateData, XUSBPSU_DCFG_HIGHSPEED);
-	/* Hook up chapter9 handler */
-	XUsbPsu_set_ch9handler((struct XUsbPsu*)UsbInstance.PrivateData,
-		XFsbl_Ch9Handler);
+	XUsbPsu_SetSpeed(&UsbInstance, XUSBPSU_DCFG_HIGHSPEED);
+	/* hook up chapter9 handler */
+	UsbInstance.Chapter9 = XFsbl_Ch9Handler;
 
 	/* Set the reset event handler */
-	XUsbPsu_set_rsthandler((struct XUsbPsu*)UsbInstance.PrivateData,
-		XFsbl_DfuReset);
-
-	DfuObj.InstancePtr = &UsbInstance;
-
-	/* Set DFU state to APP_IDLE */
-	XFsbl_DfuSetState(&UsbInstance, STATE_APP_IDLE);
-
-	/* Assign the data to usb driver */
-	XUsbPsu_set_drvdata((struct XUsbPsu*)UsbInstance.PrivateData, &Dfu_data);
+	UsbInstance.ResetIntrHandler = XFsbl_DfuReset;
 
-	/*
-	 * Enable interrupts for Reset, Disconnect, ConnectionDone, Link State
-	 * Wakeup and Overflow events.
-	 */
-	XUsbPsu_EnableIntr((struct XUsbPsu*)UsbInstance.PrivateData,
-		XUSBPSU_DEVTEN_EVNTOVERFLOWEN | XUSBPSU_DEVTEN_WKUPEVTEN
-		| XUSBPSU_DEVTEN_ULSTCNGEN | XUSBPSU_DEVTEN_CONNECTDONEEN
-		| XUSBPSU_DEVTEN_USBRSTEN | XUSBPSU_DEVTEN_DISCONNEVTEN);
+	/*Enable events for Reset, Disconnect, ConnectionDone, Link State
+	* Wakeup and Overflow events.*/
+	XUsbPsu_EnableIntr(&UsbInstance, XUSBPSU_DEVTEN_EVNTOVERFLOWEN |
+			XUSBPSU_DEVTEN_WKUPEVTEN | XUSBPSU_DEVTEN_ULSTCNGEN |
+	        XUSBPSU_DEVTEN_CONNECTDONEEN | XUSBPSU_DEVTEN_USBRSTEN |
+							XUSBPSU_DEVTEN_DISCONNEVTEN);
 
 	/* Start the controller so that Host can see our device */
-	SStatus = XUsbPsu_Start((struct XUsbPsu*)UsbInstance.PrivateData);
+	SStatus = XUsbPsu_Start(&UsbInstance);
 	if (SStatus != XFSBL_SUCCESS) {
 		Status = XFSBL_FAILURE;
 		goto END;
 	}
 
-	while ((DownloadDone < XFSBL_DOWNLOAD_COMPLETE) && \
-		(DfuObj.CurrStatus != STATE_DFU_ERROR)) {
-		XUsbPsu_IntrHandler((struct XUsbPsu*)UsbInstance.PrivateData);
+	while((DownloadDone < XFSBL_DOWNLOAD_COMPLETE) && (DfuObj.CurrStatus != STATE_DFU_ERROR)) {
+		XUsbPsu_IntrHandler(&UsbInstance);
 	}
 
 	if(DownloadDone == XFSBL_DOWNLOAD_COMPLETE) {
@@ -145,7 +144,7 @@ u32 XFsbl_UsbInit(u32 DeviceFlags)
 	{
 		Status = XFSBL_FAILURE;
 	}
-	(void)XUsbPsu_Stop((struct XUsbPsu*)UsbInstance.PrivateData);
+	(void)XUsbPsu_Stop(&UsbInstance);
 END:
 	return Status;
 }
@@ -231,13 +230,13 @@ static void XFsbl_Ch9Handler(struct Usb_DevData *InstancePtr,
 	switch (SetupData->bRequestType & XFSBL_REQ_TYPE_MASK) {
 		case XFSBL_CMD_STDREQ:
 		{
-			XFsbl_StdDevReq(InstancePtr, SetupData);
+			XFsbl_StdDevReq(SetupData);
 		}
 			break;
 
 		case XFSBL_CMD_CLASSREQ:
 		{
-			XFsbl_DfuClassReq(InstancePtr, SetupData);
+			XFsbl_DfuClassReq(SetupData);
 		}
 			break;
 
@@ -254,7 +253,6 @@ static void XFsbl_Ch9Handler(struct Usb_DevData *InstancePtr,
 /*****************************************************************************
 * This function handles a standard device request.
 *
-* @param	InstancePtr is a pointer to XUsbPsu instance of the controller.
 * @param	SetupData is a pointer to the data structure containing the
 *		setup request.
 *
@@ -263,12 +261,12 @@ static void XFsbl_Ch9Handler(struct Usb_DevData *InstancePtr,
 * @note		None.
 *
 ******************************************************************************/
-static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupData)
+static void XFsbl_StdDevReq(SetupPacket *SetupData)
 {
 	s32 SStatus;
 	u32 ReplyLen;
-	u8 Reply[XFSBL_REQ_REPLY_LEN]={0};
-	u8 TmpBuffer[DFU_STATUS_SIZE]={0};
+	static u8 Reply[XFSBL_REQ_REPLY_LEN]={0};
+	static u8 TmpBuffer[DFU_STATUS_SIZE]={0};
 	u8 EpNum = SetupData->wIndex & XFSBL_USB_ENDPOINT_NUMBER_MASK;
 	/*
 	 * Direction - 1 -- XUSBPSU_EP_DIR_IN
@@ -303,7 +301,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 					break;
 				case XFSBL_STATUS_ENDPOINT:
 				{
-					ShortVar = XUsbPsu_IsEpStalled(InstancePtr->PrivateData, EpNum, Direction);
+					ShortVar = XUsbPsu_IsEpStalled(&UsbInstance, EpNum, Direction);
 					(void)XFsbl_MemCpy(&Reply[0],&ShortVar, sizeof(u16));
 				}
 					break;
@@ -314,13 +312,13 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 					break;
 			}
 
-			SStatus = XUsbPsu_EpBufferSend(InstancePtr->PrivateData, 0U, Reply, SetupData->wLength);
+			SStatus = XUsbPsu_EpBufferSend(&UsbInstance, 0U, Reply, SetupData->wLength);
 		}
 			break;
 
 		case XFSBL_REQ_SET_ADDRESS:
 		{
-			SStatus = XUsbPsu_SetDeviceAddress(InstancePtr->PrivateData, SetupData->wValue);
+			SStatus = XUsbPsu_SetDeviceAddress(&UsbInstance, SetupData->wValue);
 		}
 			break;
 
@@ -351,7 +349,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 						Reply[8] = 0x0U;
 						Reply[9] = 0x0U;
 					}
-					SStatus = XUsbPsu_EpBufferSend(InstancePtr->PrivateData, 0,
+					SStatus = XUsbPsu_EpBufferSend(&UsbInstance, 0,
 							Reply, ReplyLen);
 				}
 					break;
@@ -364,7 +362,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 					if(ReplyLen > SetupData->wLength){
 						ReplyLen = SetupData->wLength;
 					}
-					SStatus = XUsbPsu_EpBufferSend(InstancePtr->PrivateData, 0U,
+					SStatus = XUsbPsu_EpBufferSend(&UsbInstance, 0U,
 								Reply, ReplyLen);
 				}
 					break;
@@ -377,7 +375,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 					if(ReplyLen > SetupData->wLength){
 						ReplyLen = SetupData->wLength;
 					}
-					SStatus = XUsbPsu_EpBufferSend(InstancePtr->PrivateData, 0U,
+					SStatus = XUsbPsu_EpBufferSend(&UsbInstance, 0U,
 								Reply, ReplyLen);
 				}
 					break;
@@ -390,7 +388,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 					if(ReplyLen > SetupData->wLength){
 						ReplyLen = SetupData->wLength;
 					}
-					SStatus = XUsbPsu_EpBufferSend(InstancePtr->PrivateData, 0U,
+					SStatus = XUsbPsu_EpBufferSend(&UsbInstance, 0U,
 								Reply, ReplyLen);
 				}
 				break;
@@ -411,7 +409,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 				break;
 			}
 
-			SStatus = XFsbl_SetConfiguration(InstancePtr, SetupData);
+			SStatus = XFsbl_SetConfiguration(SetupData);
 		}
 			break;
 
@@ -427,7 +425,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 				case XFSBL_STATUS_ENDPOINT:
 				{
 					if(SetupData->wValue == XFSBL_ENDPOINT_HALT) {
-							XUsbPsu_EpSetStall(InstancePtr->PrivateData, EpNum, Direction);
+							XUsbPsu_EpSetStall(&UsbInstance, EpNum, Direction);
 
 					}
 					SStatus = XST_SUCCESS;
@@ -450,7 +448,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 
 		case XFSBL_REQ_SET_INTERFACE:
 		{
-			XFsbl_DfuSetIntf(InstancePtr, SetupData);
+			XFsbl_DfuSetIntf(SetupData);
 			SStatus = XST_SUCCESS;
 		}
 			break;
@@ -458,7 +456,7 @@ static void XFsbl_StdDevReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupD
 		case XFSBL_REQ_SET_SEL:
 		{
 
-			SStatus = XUsbPsu_EpBufferRecv(InstancePtr->PrivateData, 0U, TmpBuffer, DFU_STATUS_SIZE);
+			SStatus = XUsbPsu_EpBufferRecv(&UsbInstance, 0U, TmpBuffer, DFU_STATUS_SIZE);
 		}
 			break;
 
@@ -474,7 +472,7 @@ END:
 			XFsbl_Printf(DEBUG_INFO,"\nStd dev req %d/%d error, stall 0 in out\n",
 					SetupData->bRequest, (SetupData->wValue >> 8U) & 0xFFU);
 
-			XUsbPsu_EpSetStall(InstancePtr->PrivateData, 0U, XUSBPSU_EP_DIR_OUT);
+			XUsbPsu_EpSetStall(&UsbInstance, 0U, XUSBPSU_EP_DIR_OUT);
 		}
 
 }
diff --git a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.h b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.h
index f4597d711d..5700e6b02b 100644
--- a/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.h
+++ b/lib/sw_apps/zynqmp_fsbl/src/xfsbl_usb.h
@@ -1,8 +1,28 @@
 /******************************************************************************
-* Copyright (c) 2017 - 2020 Xilinx, Inc.  All rights reserved.
-* SPDX-License-Identifier: MIT
+*
+* Copyright (C) 2017 Xilinx, Inc.  All rights reserved.
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*
+*
+*
 ******************************************************************************/
-
 /****************************************************************************/
 /**
 *
@@ -17,7 +37,6 @@
 * Ver   Who  Date     Changes
 * ----- ---- -------- -------------------------------------------------------
 * 1.0   bvikram  02/01/17 First release
-* 2.0   bvikram  09/30/20 Fix USB boot issue
 *
 * </pre>
 *
@@ -88,15 +107,14 @@ extern "C" {
 #define XFSBL_USB_ENDPOINT_DIR_MASK		0x80U
 /************************** Function Prototypes **************************/
 void XFsbl_DfuInit(void);
-void XFsbl_DfuSetIntf(struct Usb_DevData *InstancePtr, SetupPacket *SetupData);
-void XFsbl_DfuClassReq(struct Usb_DevData *InstancePtr, SetupPacket *SetupData);
+void XFsbl_DfuSetIntf(SetupPacket *SetupData);
+void XFsbl_DfuClassReq(SetupPacket *SetupData);
 void XFsbl_DfuReset(struct Usb_DevData* InstancePtr);
 u32 XFsbl_Ch9SetupDevDescReply(u8 *BufPtr, u32 BufferLen);
 u32 XFsbl_Ch9SetupCfgDescReply(u8 *BufPtr, u32 BufferLen);
 u32 XFsbl_Ch9SetupStrDescReply(u8 *BufPtr, u32 BufferLen, u8 Index);
 u32 XFsbl_Ch9SetupBosDescReply(u8 *BufPtr, u32 BufferLen);
-s32 XFsbl_SetConfiguration(struct Usb_DevData *InstancePtr, SetupPacket *Ctrl);
-void XFsbl_DfuSetState(struct Usb_DevData* InstancePtr, u32 DfuState);
+s32 XFsbl_SetConfiguration(SetupPacket *Ctrl);
 u32 XFsbl_UsbInit(u32 DeviceFlags);
 u32 XFsbl_UsbCopy(u32 SrcAddress, PTRSIZE DestAddress, u32 Length);
 u32 XFsbl_UsbRelease(void);
@@ -104,7 +122,7 @@ u32 XFsbl_CheckTempDfuMemory(u32 Offset);
 
 #endif/*XFSBL_USB*/
 #ifdef __cplusplus
-}
+extern "C" }
 #endif
 
 #endif /* XFSBL_USB_H */
